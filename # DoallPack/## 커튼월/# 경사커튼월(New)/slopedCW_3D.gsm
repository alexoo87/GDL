!===============================================================================================
!	경사커튼월
!===============================================================================================

!	Resolution
resol	12
if	GLOB_FEEDBACK_MODE	then
	resol	4
endif

!	텍스트 정의
define style	"txtSty_Fix"	"맑은 고딕",	txtSize,	5,	0

!	벡터
_dx = 0
_dy = ctwHgt*tan(aTilt)
_dz = ctwHgt

!	수직프레임 유형
VFRAME_CORNER = 1
VFRAME_MULLION = 2

!	수평프레임 유형
HFRAME_CORNER = 1
HFRAME_TRANSOM = 2

!	코너프레임 유형에 따른 Offset 값
if	iFrmTypeL = FRAME_BOUNDARY	then
	_offsetL_PNL = (frmWdtL + gskWdtL)/2
	_offsetL_ETC = frmWdtL
else
	_offsetL_PNL = gskWdtL/2
	_offsetL_ETC = frmWdtL/2
endif

if	iFrmTypeR = FRAME_BOUNDARY	then
	_offsetR_PNL = (frmWdtR + gskWdtR)/2
	_offsetR_ETC = frmWdtR
else
	_offsetR_PNL = gskWdtR/2
	_offsetR_ETC = frmWdtR/2
endif

!-----------------------------------------------------------------------------------------------
!	2D Display
!-----------------------------------------------------------------------------------------------
if	bSymbol	then
	_n2Dcut = 0
	if	iProjectTo = PROJECTTO_FLOORPLAN | (iProjectTo = PROJECTTO_ABSOLUTE & btmPlaneHgt < cutPlaneHgt)	then
		addz	btmPlaneHgt
			cutplane{2}	180,	2	:	_n2Dcut = _n2Dcut + 1
		del 1
	endif

	addz	cutPlaneHgt
		cutplane{2}	180*(iProjectType = 2),	1	:	_n2Dcut = _n2Dcut + 1
	del 1

	if	iProjectTo = PROJECTTO_FLOORPLAN | (iProjectTo = PROJECTTO_ABSOLUTE & btmPlaneHgt < cutPlaneHgt)	then
		addz	topPlaneHgt
			cutplane{2}	0,	2	:	_n2Dcut = _n2Dcut + 1
		del 1
	endif
endif

!-----------------------------------------------------------------------------------------------
!	Hotspot
!-----------------------------------------------------------------------------------------------
!	커튼월 기울기
_ctw = ctwHgt/cos(aTilt)
addx	ctwWdt/2
	hotspot	0,	0,					_ctw,				unID,	aTilt,	4+128	:	unID = unID + 1
	hotspot	0,	_ctw*sin(aTilt),	_ctw*cos(aTilt),	unID,	aTilt,	5		:	unID = unID + 1
	hotspot	0,	0,					0,					unID,	aTilt,	6		:	unID = unID + 1
	hotspot	-1,	0,					0,					unID,	aTilt,	7		:	unID = unID + 1
del 1

!	수직프레임 간격
for	i = 1	to	nMln + 1
	hotspot	0,			0,	0,	unID,	mlnGap[i],	1+128	:	unID = unID + 1
	hotspot	-1,			0,	0,	unID,	mlnGap[i],	3		:	unID = unID + 1
	hotspot	mlnGap[i],	0,	0,	unID,	mlnGap[i],	2		:	unID = unID + 1

	addx	mlnGap[i]
next	i

del	nMln + 1

!	수평프레임 간격
_hLct = 0
for	i = 1	to	nTrs + 1
	_hLct = _hLct + trsGap[i]

	for	j = 1	to	2
		addx	ctwWdt*(j - 1)
			addy	_hLct*tan(aTilt)
				hotspot	0,	0,	0,			unID,	trsGap[i],	1+128	:	unID = unID + 1
				hotspot	0,	0,	-1,			unID,	trsGap[i],	3		:	unID = unID + 1
				hotspot	0,	0,	trsGap[i],	unID,	trsGap[i],	2		:	unID = unID + 1
			del 1
		del 1
	next	j

	addz	trsGap[i]
next	i

del nTrs + 1

!-----------------------------------------------------------------------------------------------
!	수직프레임
!-----------------------------------------------------------------------------------------------
group	"_vFrame"
	!	좌측프레임
	if	bFrmL	then
		_frmType = iFrmTypeL
		_frmClass = VFRAME_CORNER
		_frmWdt = frmWdtL
		_frmThk = frmThkL
		_gskWdt = gskWdtL

		gosub	"vFrame"
	endif

	!	우측프레임
	if	bFrmR	then
		_frmType = iFrmTypeR
		_frmClass = VFRAME_CORNER
		_frmWdt = frmWdtR
		_frmThk = frmThkR
		_gskWdt = gskWdtR

		addx	ctwWdt
			mulx	-1
				gosub	"vFrame"
			del 1
		del 1
	endif

	!	멀리언
	_bMln = (nMln > eps)
	if	_bMln	then
		_frmClass = VFRAME_MULLION
		_frmWdt = mlnWdt
		_frmThk = mlnThk
		_gskWdt = mlnGskWdt

		for	i = 1	to	nMln
			addx	mlnGap[i]

			gosub	"vFrame"
		next	i

		del nMln
	endif
endgroup

group	"_vFrameCut"
	!	좌측프레임
	if	bFrmL	then
		_frmType = iFrmTypeL
		_frmClass = VFRAME_CORNER
		_frmWdt = frmWdtL
		_frmThk = frmThkL + 2
		_gskWdt = gskWdtL

		gosub	"vFrame"
	endif

	!	우측프레임
	if	bFrmR	then
		_frmType = iFrmTypeR
		_frmClass = VFRAME_CORNER
		_frmWdt = frmWdtR
		_frmThk = frmThkR + 2
		_gskWdt = gskWdtR

		addx	ctwWdt
			mulx	-1
				gosub	"vFrame"
			del 1
		del 1
	endif

	!	멀리언
	_bMln = (nMln > eps)
	if	_bMln	then
		_frmClass = VFRAME_MULLION
		_frmWdt = mlnWdt
		_frmThk = mlnThk + 2
		_gskWdt = mlnGskWdt

		for	i = 1	to	nMln
			addx	mlnGap[i]

			gosub	"vFrame"
		next	i

		del nMln
	endif
endgroup

! placegroup	"_vFrame"

!-----------------------------------------------------------------------------------------------
!	수평프레임
!-----------------------------------------------------------------------------------------------
group	"_hFrame"
	!	하부프레임
	if	bFrmB	then
		!	자르기 좌표 정의
		_cutHgt1 = 0
		_cutWdt1 = _cutHgt1*tan(aTilt)
		_cutHgt2 = (frmWdtB - gskWdtB)/2
		_cutWdt2 = _cutHgt2*tan(aTilt)
		_cutHgt3 = (frmWdtB + gskWdtB)/2
		_cutWdt3 = _cutHgt3*tan(aTilt)
		_cutHgt4 = frmWdtB
		_cutWdt4 = _cutHgt4*tan(aTilt)

		_frmType = iFrmTypeB
		_frmClass = HFRAME_CORNER
		_frmWdt = frmWdtB
		_frmThk = frmThkB

		gosub	"hFrame"
	endif

	!	상부프레임
	if	bFrmT	then
		!	자르기 좌표 정의
		_cutHgt1 = frmWdtT
		_cutWdt1 = _cutHgt1*tan(aTilt)
		_cutHgt2 = (frmWdtT + gskWdtT)/2
		_cutWdt2 = _cutHgt2*tan(aTilt)
		_cutHgt3 = (frmWdtT - gskWdtT)/2
		_cutWdt3 = _cutHgt3*tan(aTilt)
		_cutHgt4 = 0
		_cutWdt4 = _cutHgt4*tan(aTilt)

		_frmType = iFrmTypeT
		_frmClass = HFRAME_CORNER
		_frmWdt = frmWdtT
		_frmThk = frmThkT

		_ratio = (ctwHgt - frmWdtT)/ctwHgt

		add	_dx*_ratio,	_dy*_ratio,	_dz*_ratio
			gosub	"hFrame"
		del 1
	endif

	_bTrs = (nTrs > eps)
	if	_bTrs	then
		!	자르기 좌표 정의
		_cutHgt1 = 0
		_cutWdt1 = _cutHgt1*tan(aTilt)
		_cutHgt2 = (trsWdt - trsGskWdt)/2
		_cutWdt2 = _cutHgt2*tan(aTilt)
		_cutHgt3 = (trsWdt + trsGskWdt)/2
		_cutWdt3 = _cutHgt3*tan(aTilt)
		_cutHgt4 = trsWdt
		_cutWdt4 = _cutHgt4*tan(aTilt)

		_frmClass = HFRAME_TRANSOM
		_frmWdt = trsWdt
		_frmThk = trsThk

		_trsLct = 0
		for	j = 1	to	nTrs
			_trsLct = _trsLct + trsGap[j]
			_trsRatio = (_trsLct - trsWdt/2)/ctwHgt

			add	_dx*_trsRatio,	_dy*_trsRatio,	_dz*_trsRatio
				gosub	"hFrame"
			del 1
		next	j
	endif
endgroup

placegroup	subgroup("_hFrame",	"_vFrameCut")

!-----------------------------------------------------------------------------------------------
!	패널
!-----------------------------------------------------------------------------------------------

group	"_panel"

for	i = 1	to	(nMln + 1)
	for	j = 1	to	(nTrs + 1)

		!	변수 정의
		_pnlType = iPnlType[i][j]
		_hingeType = iHingeType[i][j]

		_bSingle = (_pnlType = PNL_FIX | _pnlType = PNL_PROJECT | _pnlType = PNL_PROJECT_SMOKE | _pnlType = PNL_SPANDREL | \
					_pnlType = PNL_SPANDREL_SUB | _pnlType = PNL_SPANDREL_SUB2 | _pnlType = PNL_SPANDREL_SUB3 | _pnlType = PNL_GRILL)

		!	패널 너비
		_pnlWdt = 0
		_etcWdt = 0
		if	nMln < eps	then
			_pnlWdt = mlnGap[i] - (_offsetL_PNL + _offsetR_PNL)
			_etcWdt = mlnGap[i] - (_offsetL_ETC + _offsetR_ETC)
			_minFrmThk1 = min(frmThkL,	frmThkR)
		else
			if	i = 1	then
				_pnlWdt = mlnGap[i] - (_offsetL_PNL + mlnGskWdt/2)
				_etcWdt = mlnGap[i] - (_offsetL_ETC + mlnWdt/2)
				_minFrmThk1 = min(frmThkL,	mlnThk)
			endif
			if	i # 1 & i # (nMln + 1)	then
				_pnlWdt = mlnGap[i] - mlnGskWdt
				_etcWdt = mlnGap[i] - mlnWdt
				_minFrmThk1 = mlnThk
			endif
			if	i = (nMln + 1)	then
				_pnlWdt = mlnGap[i] - (_offsetR_PNL + mlnGskWdt/2)
				_etcWdt = mlnGap[i] - (_offsetR_ETC + mlnWdt/2)
				_minFrmThk1 = min(frmThkR,	mlnThk)
			endif
		endif

		!	패널 높이
		_pnlHgt = 0
		_etcHgt = 0
		if	nTrs < eps	then
			_pnlLct = 0
			_pnlHgt = trsGap[j] - ((frmWdtB + gskWdtB)/2 + (frmWdtT + gskWdtT)/2)
			_etcHgt = trsGap[j] - (frmWdtB + frmWdtT)
			_minFrmThk2 = min(frmThkB,	frmThkT)
		else
			if	j = 1	then
				_pnlLct = 0
				_pnlHgt = trsGap[j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
				_etcHgt = trsGap[j] - (frmWdtB + trsWdt/2)
				_minFrmThk2 = min(frmThkB,	trsThk)
			endif
			if	j # 1 & j # (nTrs + 1)	then
				_pnlLct = _pnlLct + trsGap[j - 1]
				_pnlHgt = trsGap[j] - trsGskWdt
				_etcHgt = trsGap[j] - trsWdt
				_minFrmThk2 = trsThk
			endif
			if	j = (nTrs + 1)	then
				_pnlLct = _pnlLct + trsGap[j - 1]
				_pnlHgt = trsGap[j] - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)
				_etcHgt = trsGap[j] - (frmWdtT + trsWdt/2)
				_minFrmThk2 = min(frmThkT,	trsThk)
			endif
		endif

		!	최소 프레임 두께
		_minFrmThk = min(_minFrmThk1,	_minFrmThk2)

		!	패널 벡터
		_pnlX = 0
		_pnlY = _pnlHgt*tan(aTilt)
		_pnlZ = _pnlHgt

		_etcX = 0
		_etcY = _etcHgt*tan(aTilt)
		_etcZ = _etcHgt

		!	패널 x위치/높이 비율
		if	nMln < eps	then
			_xPosPnl = _offsetL_PNL
			_xPosEtc = _offsetL_ETC
		else
			if	i = 1	then
				_xPosPnl = _offsetL_PNL
				_xPosEtc = _offsetL_ETC
			else
				_xPosPnl = mlnGskWdt/2
				_xPosEtc = mlnWdt/2
			endif
		endif

		if	nTrs < eps	then
			_pnlRatio = (_pnlLct + (frmWdtB + gskWdtB)/2)/ctwHgt
			_etcRatio = (_pnlLct + frmWdtB)/ctwHgt
		else
			if	j = 1	then
				_pnlRatio = (_pnlLct + (frmWdtB + gskWdtB)/2)/ctwHgt
				_etcRatio = (_pnlLct + frmWdtB)/ctwHgt
			else
				_pnlRatio = (_pnlLct + trsGskWdt/2)/ctwHgt
				_etcRatio = (_pnlLct + trsWdt/2)/ctwHgt
			endif
		endif

		!-----------------------------------------------------------------------------------------------
		!	단일 창호 유형
		!-----------------------------------------------------------------------------------------------
		if	_bSingle	then
			gosub	"pnl_Matrix"
		endif

		!-----------------------------------------------------------------------------------------------
		!	복합창호 유형
		!-----------------------------------------------------------------------------------------------
		if	not(_bSingle)	then

			!	2분할 패널 유형(가로)
			!-----------------------------------------------------------------------------------------------
			if	_pnlType = PNL_SEP2_HORIZON	then
				!	변수정의
				_idx = iSepType[i][j]
				_pnlType1 = iSepType_2Horz[_idx][1]
				_pnlType2 = iSepType_2Horz[_idx][2]
				_hingeType1 = iHingeType_2Horz[_idx][1]
				_hingeType2 = iHingeType_2Horz[_idx][2]

				_pnlWdt1 = 0
				_pnlWdt2 = 0

				_xPosPnl1 = 0
				_xPosPnl2 = sep2_Horz[i][j] + mlnGskWdt/2

				if	nMln < eps	then
					_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL + mlnGskWdt/2)
					_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_PNL + mlnGskWdt/2)

					_xPosPnl1 = _offsetL_PNL
				else
					if	i = 1	then
						_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL + mlnGskWdt/2)
						_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - mlnGskWdt

						_xPosPnl1 = _offsetL_PNL
					endif
					if	i # 1 & i # (nMln + 1)	then
						_pnlWdt1 = sep2_Horz[i][j] - mlnGskWdt
						_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - mlnGskWdt

						_xPosPnl1 = mlnGskWdt/2
					endif
					if	i = (nMln + 1)	then
						_pnlWdt1 = sep2_Horz[i][j] - mlnGskWdt
						_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_PNL + mlnGskWdt/2)

						_xPosPnl1 = mlnGskWdt/2
					endif
				endif

				_etcWdt1 = 0
				_etcWdt2 = 0

				_xPosEtc1 = 0
				_xPosEtc2 = sep2_Horz[i][j] + mlnWdt/2

				if	nMln < eps	then
					_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC + mlnWdt/2)
					_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_ETC + mlnWdt/2)

					_xPosEtc1 = _offsetL_ETC
				else
					if	i = 1	then
						_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC + mlnWdt/2)
						_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - mlnWdt

						_xPosEtc1 = _offsetL_ETC
					endif
					if	i # 1 & i # (nMln + 1)	then
						_etcWdt1 = sep2_Horz[i][j] - mlnWdt
						_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - mlnWdt

						_xPosEtc1 = mlnWdt/2
					endif
					if	i = (nMln + 1)	then
						_etcWdt1 = sep2_Horz[i][j] - mlnWdt
						_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_ETC + mlnWdt/2)

						_xPosEtc1 = mlnWdt/2
					endif
				endif

				!	Hotspot
				add	_dx*_pnlRatio,	_dy*_pnlRatio + _pnlY/2,	_dz*_pnlRatio + _pnlHgt/2
					hotspot	0,					0,	0,	unID,	sep2_Horz[i][j],	1+128	:	unID = unID + 1
					hotspot	-1,					0,	0,	unID,	sep2_Horz[i][j],	3		:	unID = unID + 1
					hotspot	sep2_Horz[i][j],	0,	0,	unID,	sep2_Horz[i][j],	2		:	unID = unID + 1
				del 1

				!	1번 영역
				_pnlType = _pnlType1
				_hingeType = _hingeType1
				_pnlWdt = _pnlWdt1
				_etcWdt = _etcWdt1
				_xPosPnl = _xPosPnl1
				_xPosEtc = _xPosEtc1

				gosub	"pnl_Matrix"

				!	2번 영역
				_pnlType = _pnlType2
				_hingeType = _hingeType2
				_pnlWdt = _pnlWdt2
				_etcWdt = _etcWdt2
				_xPosPnl = _xPosPnl2
				_xPosEtc = _xPosEtc2

				gosub	"pnl_Matrix"

				!	수직프레임
				_xPosFrm = sep2_Horz[i][j]
				gosub	"pnl_vFrame"
			endif

			!	3분할 패널 유형(가로)
			!-----------------------------------------------------------------------------------------------
			if	_pnlType = PNL_SEP3_HORIZON	then
				!	변수정의
				_idx = iSepType[i][j]
				_pnlType1 = iSepType_3Horz[_idx][1]
				_pnlType2 = iSepType_3Horz[_idx][2]
				_pnlType3 = iSepType_3Horz[_idx][3]
				_hingeType1 = iHingeType_3Horz[_idx][1]
				_hingeType2 = iHingeType_3Horz[_idx][2]
				_hingeType3 = iHingeType_3Horz[_idx][3]

				_pnlWdt1 = 0
				_pnlWdt2 = 0
				_pnlWdt3 = 0

				_xPosPnl1 = 0
				_xPosPnl2 = sep2_Horz[i][j] + mlnGskWdt/2
				_xPosPnl3 = sep3_Horz[i][j] + mlnGskWdt/2

				if	nMln < eps	then
					_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL + mlnGskWdt/2)
					_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnGskWdt
					_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_PNL + mlnGskWdt/2)

					_xPosPnl1 = _offsetL_PNL
				else
					if	i = 1	then
						_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL + mlnGskWdt/2)
						_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnGskWdt
						_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - mlnGskWdt

						_xPosPnl1 = _offsetL_PNL
					endif
					if	i # 1 & i # (nMln + 1)	then
						_pnlWdt1 = sep2_Horz[i][j] - mlnGskWdt
						_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnGskWdt
						_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - mlnGskWdt

						_xPosPnl1 = mlnGskWdt/2
					endif
					if	i = (nMln + 1)	then
						_pnlWdt1 = sep2_Horz[i][j] - mlnGskWdt
						_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnGskWdt
						_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_PNL + mlnGskWdt/2)

						_xPosPnl1 = mlnGskWdt/2
					endif
				endif

				_etcWdt1 = 0
				_etcWdt2 = 0
				_etcWdt3 = 0

				_xPosEtc1 = 0
				_xPosEtc2 = sep2_Horz[i][j] + mlnWdt/2
				_xPosEtc3 = sep3_Horz[i][j] + mlnWdt/2

				if	nMln < eps	then
					_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC + mlnWdt/2)
					_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnWdt
					_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_ETC + mlnWdt/2)

					_xPosEtc1 = _offsetL_ETC
				else
					if	i = 1	then
						_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC + mlnWdt/2)
						_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnWdt
						_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - mlnWdt

						_xPosEtc1 = _offsetL_ETC
					endif
					if	i # 1 & i # (nMln + 1)	then
						_etcWdt1 = sep2_Horz[i][j] - mlnWdt
						_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnWdt
						_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - mlnWdt

						_xPosEtc1 = mlnWdt/2
					endif
					if	i = (nMln + 1)	then
						_etcWdt1 = sep2_Horz[i][j] - mlnWdt
						_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - mlnWdt
						_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_ETC + mlnWdt/2)

						_xPosEtc1 = mlnWdt/2
					endif
				endif

				!	Hotspot
				add	_dx*_pnlRatio,	_dy*_pnlRatio + _pnlY/2,	_dz*_pnlRatio + _pnlHgt/2
					hotspot	0,					0,	0,	unID,	sep2_Horz[i][j],	1+128	:	unID = unID + 1
					hotspot	-1,					0,	0,	unID,	sep2_Horz[i][j],	3		:	unID = unID + 1
					hotspot	sep2_Horz[i][j],	0,	0,	unID,	sep2_Horz[i][j],	2		:	unID = unID + 1

					hotspot	0,					0,	0,	unID,	sep3_Horz[i][j],	1+128	:	unID = unID + 1
					hotspot	-1,					0,	0,	unID,	sep3_Horz[i][j],	3		:	unID = unID + 1
					hotspot	sep3_Horz[i][j],	0,	0,	unID,	sep3_Horz[i][j],	2		:	unID = unID + 1
				del 1

				!	1번 영역
				_pnlType = _pnlType1
				_hingeType = _hingeType1
				_pnlWdt = _pnlWdt1
				_etcWdt = _etcWdt1
				_xPosPnl = _xPosPnl1
				_xPosEtc = _xPosEtc1

				gosub	"pnl_Matrix"

				!	2번 영역
				_pnlType = _pnlType2
				_hingeType = _hingeType2
				_pnlWdt = _pnlWdt2
				_etcWdt = _etcWdt2
				_xPosPnl = _xPosPnl2
				_xPosEtc = _xPosEtc2

				gosub	"pnl_Matrix"

				!	3번 영역
				_pnlType = _pnlType3
				_hingeType = _hingeType3
				_pnlWdt = _pnlWdt3
				_etcWdt = _etcWdt3
				_xPosPnl = _xPosPnl3
				_xPosEtc = _xPosEtc3

				gosub	"pnl_Matrix"

				!	수직프레임
				_xPosFrm = sep2_Horz[i][j]
				gosub	"pnl_vFrame"

				_xPosFrm = sep3_Horz[i][j]
				gosub	"pnl_vFrame"
			endif

			!	2분할 패널 유형(세로)
			!-----------------------------------------------------------------------------------------------
			if	_pnlType = PNL_SEP2_VERTICAL	then
				!	변수정의
				_idx = iSepType[i][j]
				_pnlType1 = iSepType_2Vert[1][_idx]
				_pnlType2 = iSepType_2Vert[2][_idx]
				_hingeType1 = iHingeType_2Vert[1][_idx]
				_hingeType2 = iHingeType_2Vert[2][_idx]

				_pnlHgt1 = 0
				_pnlHgt2 = 0

				_etcHgt1 = 0
				_etcHgt2 = 0

				if	nTrs < eps	then
					_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
					_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

					_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
					_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - (frmWdtT + trsWdt/2)
				else
					if	j = 1	then
						_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
						_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsGskWdt

						_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
						_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsWdt
					endif
					if	j # 1 & j # (nTrs + 1)	then
						_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
						_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsGskWdt

						_etcHgt1 = sep2_Vert[i][j] - trsWdt
						_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsWdt
					endif
					if	j = (nTrs + 1)	then
						_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
						_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

						_etcHgt1 = sep2_Vert[i][j] - trsWdt
						_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - (frmWdtT + trsWdt/2)
					endif
				endif

				!	패널 벡터
				_pnlX1 = 0
				_pnlY1 = _pnlHgt1*tan(aTilt)
				_pnlZ1 = _pnlHgt1

				_pnlX2 = 0
				_pnlY2 = _pnlHgt2*tan(aTilt)
				_pnlZ2 = _pnlHgt2

				_etcX1 = 0
				_etcY1 = _etcHgt1*tan(aTilt)
				_etcZ1 = _etcHgt1

				_etcX2 = 0
				_etcY2 = _etcHgt2*tan(aTilt)
				_etcZ2 = _etcHgt2

				!	패널 높이 비율
				_pnlRatio1 = _pnlRatio
				_pnlRatio2 = (_pnlLct + sep2_Vert[i][j] + trsGskWdt/2)/ctwHgt

				_etcRatio1 = _etcRatio
				_etcRatio2 = (_pnlLct + sep2_Vert[i][j] + trsWdt/2)/ctwHgt

				_hRatio = (_pnlLct + sep2_Vert[i][j])/ctwHgt

				!	Hotspot
				add	mlnGap[i]/2,	_dy*_hRatio,	_pnlLct
					hotspot	0,	0,	0,					unID,	sep2_Vert[i][j],	1+128	:	unID = unID + 1
					hotspot	0,	0,	-1,					unID,	sep2_Vert[i][j],	3		:	unID = unID + 1
					hotspot	0,	0,	sep2_Vert[i][j],	unID,	sep2_Vert[i][j],	2		:	unID = unID + 1
				del 1

				!	1번 영역
				_pnlType = _pnlType1
				_hingeType = _hingeType1
				_etcHgt = _etcHgt1
				_pnlX = _pnlX1
				_pnlY = _pnlY1
				_pnlZ = _pnlZ1
				_etcX = _etcX1
				_etcY = _etcY1
				_etcZ = _etcZ1
				_pnlRatio = _pnlRatio1
				_etcRatio = _etcRatio1

				gosub	"pnl_Matrix"

				!	2번 영역
				_pnlType = _pnlType2
				_hingeType = _hingeType2
				_etcHgt = _etcHgt2
				_pnlX = _pnlX2
				_pnlY = _pnlY2
				_pnlZ = _pnlZ2
				_etcX = _etcX2
				_etcY = _etcY2
				_etcZ = _etcZ2
				_pnlRatio = _pnlRatio2
				_etcRatio = _etcRatio2

				gosub	"pnl_Matrix"

				!	수평프레임
				_frmRatio = (_pnlLct + sep2_Vert[i][j] - trsWdt/2)/ctwHgt
				gosub	"pnl_hFrame"
			endif

			!	3분할 패널 유형(세로)
			!-----------------------------------------------------------------------------------------------
			if	_pnlType = PNL_SEP3_VERTICAL	then
				!	변수정의
				_idx = iSepType[i][j]
				_pnlType1 = iSepType_3Vert[1][_idx]
				_pnlType2 = iSepType_3Vert[2][_idx]
				_pnlType3 = iSepType_3Vert[3][_idx]
				_hingeType1 = iHingeType_3Vert[1][_idx]
				_hingeType2 = iHingeType_3Vert[2][_idx]
				_hingeType3 = iHingeType_3Vert[3][_idx]

				_pnlHgt1 = 0
				_pnlHgt2 = 0
				_pnlHgt3 = 0

				_etcHgt1 = 0
				_etcHgt2 = 0
				_etcHgt3 = 0

				if	nTrs < eps	then
					_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
					_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
					_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

					_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
					_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
					_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - (frmWdtT + trsWdt/2)
				else
					if	j = 1	then
						_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
						_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
						_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsGskWdt

						_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
						_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
						_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsWdt
					endif
					if	j # 1 & j # (nTrs + 1)	then
						_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
						_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
						_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsGskWdt

						_etcHgt1 = sep2_Vert[i][j] - trsWdt
						_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
						_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsWdt
					endif
					if	j = (nTrs + 1)	then
						_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
						_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
						_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

						_etcHgt1 = sep2_Vert[i][j] - trsWdt
						_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
						_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - (frmWdtT + trsWdt/2)
					endif
				endif

				!	패널 벡터
				_pnlX1 = 0
				_pnlY1 = _pnlHgt1*tan(aTilt)
				_pnlZ1 = _pnlHgt1

				_pnlX2 = 0
				_pnlY2 = _pnlHgt2*tan(aTilt)
				_pnlZ2 = _pnlHgt2

				_pnlX3 = 0
				_pnlY3 = _pnlHgt3*tan(aTilt)
				_pnlZ3 = _pnlHgt3

				_etcX1 = 0
				_etcY1 = _etcHgt1*tan(aTilt)
				_etcZ1 = _etcHgt1

				_etcX2 = 0
				_etcY2 = _etcHgt2*tan(aTilt)
				_etcZ2 = _etcHgt2

				_etcX3 = 0
				_etcY3 = _etcHgt3*tan(aTilt)
				_etcZ3 = _etcHgt3

				!	패널 높이 비율
				_pnlRatio1 = _pnlRatio
				_pnlRatio2 = (_pnlLct + sep2_Vert[i][j] + trsGskWdt/2)/ctwHgt
				_pnlRatio3 = (_pnlLct + sep3_Vert[i][j] + trsGskWdt/2)/ctwHgt

				_etcRatio1 = _etcRatio
				_etcRatio2 = (_pnlLct + sep2_Vert[i][j] + trsWdt/2)/ctwHgt
				_etcRatio3 = (_pnlLct + sep3_Vert[i][j] + trsWdt/2)/ctwHgt

				_hRatio1 = (_pnlLct + sep2_Vert[i][j])/ctwHgt
				_hRatio2 = (_pnlLct + sep3_Vert[i][j])/ctwHgt

				!	Hotspot
				add	mlnGap[i]/2,	0,	_pnlLct
					addy	_dy*_hRatio1
						hotspot	0,	0,	0,					unID,	sep2_Vert[i][j],	1+128	:	unID = unID + 1
						hotspot	0,	0,	-1,					unID,	sep2_Vert[i][j],	3		:	unID = unID + 1
						hotspot	0,	0,	sep2_Vert[i][j],	unID,	sep2_Vert[i][j],	2		:	unID = unID + 1
					del 1

					addy	_dy*_hRatio2
						hotspot	0,	0,	0,					unID,	sep3_Vert[i][j],	1+128	:	unID = unID + 1
						hotspot	0,	0,	-1,					unID,	sep3_Vert[i][j],	3		:	unID = unID + 1
						hotspot	0,	0,	sep3_Vert[i][j],	unID,	sep3_Vert[i][j],	2		:	unID = unID + 1
					del 1
				del 1

				!	1번 영역
				_pnlType = _pnlType1
				_hingeType = _hingeType1
				_etcHgt = _etcHgt1
				_pnlX = _pnlX1
				_pnlY = _pnlY1
				_pnlZ = _pnlZ1
				_etcX = _etcX1
				_etcY = _etcY1
				_etcZ = _etcZ1
				_pnlRatio = _pnlRatio1
				_etcRatio = _etcRatio1

				gosub	"pnl_Matrix"

				!	2번 영역
				_pnlType = _pnlType2
				_hingeType = _hingeType2
				_etcHgt = _etcHgt2
				_pnlX = _pnlX2
				_pnlY = _pnlY2
				_pnlZ = _pnlZ2
				_etcX = _etcX2
				_etcY = _etcY2
				_etcZ = _etcZ2
				_pnlRatio = _pnlRatio2
				_etcRatio = _etcRatio2

				gosub	"pnl_Matrix"

				!	3번 영역
				_pnlType = _pnlType3
				_hingeType = _hingeType3
				_etcHgt = _etcHgt3
				_pnlX = _pnlX3
				_pnlY = _pnlY3
				_pnlZ = _pnlZ3
				_etcX = _etcX3
				_etcY = _etcY3
				_etcZ = _etcZ3
				_pnlRatio = _pnlRatio3
				_etcRatio = _etcRatio3

				gosub	"pnl_Matrix"

				!	수평프레임
				_frmRatio = (_pnlLct + sep2_Vert[i][j] - trsWdt/2)/ctwHgt
				gosub	"pnl_hFrame"

				_frmRatio = (_pnlLct + sep3_Vert[i][j] - trsWdt/2)/ctwHgt
				gosub	"pnl_hFrame"
			endif
		endif

	next	j

	addx	mlnGap[i]
next	i

del (nMln + 1)

endgroup

_panel1 = subgroup("_panel",	"_vFrameCut")
_panel2 = subgroup(_panel1,	"_hFrame")

!-----------------------------------------------------------------------------------------------
!	그룹 배치
!-----------------------------------------------------------------------------------------------
placegroup	_panel2
placegroup	"_vFrame"


!-----------------------------------------------------------------------------------------------
!	2D Display
!-----------------------------------------------------------------------------------------------
if	bSymbol	then
	for	i = 1	to	_n2Dcut
		cutend
	next	i
endif

!-----------------------------------------------------------------------------------------------
!	창호입면도
!-----------------------------------------------------------------------------------------------

! if	_iWinElev = WINELEV_ON	then
if	_iWinElev = WINELEV_ON & (GLOB_VIEW_TYPE = 4 | GLOB_VIEW_TYPE = 5)	then
	!	Hotspot
	addy	yPosGuide
		hotspot	0,			0,	zPosGuide,	unID,	xPosGuide,	1+128	:	unID = unID + 1
		hotspot	-1,			0,	zPosGuide,	unID,	xPosGuide,	3		:	unID = unID + 1
		hotspot	xPosGuide,	0,	zPosGuide,	unID,	xPosGuide,	2		:	unID = unID + 1

		addx	ctwWdt/2
			hotspot	0,	0,	0,			unID,	zPosGuide,	1+128	:	unID = unID + 1
			hotspot	0,	0,	-1,			unID,	zPosGuide,	3		:	unID = unID + 1
			hotspot	0,	0,	zPosGuide,	unID,	zPosGuide,	2		:	unID = unID + 1
		del 1
	del 1

	!	변수 정의
	_elevThk = eps
	_elevHgt = ctwHgt/cos(aTilt)

	_zPosCutBtm = 0
	_zPosCutTop = _elevHgt
	if	not(bFrmB)	then
		_zPosCutBtm = frmWdtB/cos(aTilt)
	endif
	if	not(bFrmT)	then
		_zPosCutTop = _zPosCutTop - frmWdtT/cos(aTilt)
	endif

	if	iFrmTypeL = FRAME_BOUNDARY	then
		_offsetL_PNL_Elev = (frmWdtL + gskWdtL)/2
		_offsetL_ETC_Elev = frmWdtL
	else
		if	iMlnType = MLN_TYPE1	then
			_offsetL_PNL_Elev = gskWdtL/2
			_offsetL_ETC_Elev = frmWdtL/2
		else
			_offsetL_PNL_Elev = frmWdtL/2
			_offsetL_ETC_Elev = frmWdtL/2
		endif
	endif

	if	iFrmTypeR = FRAME_BOUNDARY	then
		_offsetR_PNL_Elev = (frmWdtR + gskWdtR)/2
		_offsetR_ETC_Elev = frmWdtR
	else
		if	iMlnType = MLN_TYPE1	then
			_offsetR_PNL_Elev = gskWdtR/2
			_offsetR_ETC_Elev = frmWdtR/2
		else
			_offsetR_PNL_Elev = frmWdtR/2
			_offsetR_ETC_Elev = frmWdtR/2
		endif
	endif

	if	iMlnType = MLN_TYPE1	then
		_offsetM_PNL_Elev = mlnGskWdt/2
		_offsetM_ETC_Elev = mlnWdt/2
	else
		_offsetM_PNL_Elev = mlnWdt/2
		_offsetM_ETC_Elev = mlnWdt/2
	endif

	!	창호입면도
	add	xPosGuide,	yPosGuide,	zPosGuide
	rotz	aGuide
	rotx	-90
		
		!	수직프레임
		!-----------------------------------------------------------------------------------------------
		_nCut = 0
		addy	-_zPosCutBtm
			cutplane	1,	0,	1,	0	:	_nCut = _nCut + 1
		del 1
		addy	-_zPosCutTop
			cutplane	1,	0,	1,	1	:	_nCut = _nCut + 1
		del 1

			if	bFrmL	then
				_frmType = iFrmTypeL
				_frmClass = VFRAME_CORNER
				_frmWdt = frmWdtL
				_gskWdt = gskWdtL

				gosub	"elev_vFrame"
			endif

			if	bFrmR	then
				_frmType = iFrmTypeR
				_frmClass = VFRAME_CORNER
				_frmWdt = frmWdtR
				_gskWdt = gskWdtR

				addx	ctwWdt
					mulx	-1
						gosub	"elev_vFrame"
					del 1
				del 1
			endif

			_bMln = (nMln > eps)

			if	_bMln	then
				_frmClass = VFRAME_MULLION
				_frmWdt = mlnWdt
				_gskWdt = mlnGskWdt

				for	i = 1	to	nMln
					addx	mlnGap[i]

					gosub	"elev_vFrame"
				next	i

				del nMln
			endif

		for	c = 1	to	_nCut
			cutend
		next	c

		!	수평프레임/분할 패널 내부 수평프레임
		!-----------------------------------------------------------------------------------------------
		for	i = 1	to	(nMln + 1)
			!	프레임 오프셋 거리
			_xOffFrmL_Elev = _offsetL_PNL_Elev
			_xOffMlnL_Elev = _offsetM_PNL_Elev
			if	iFrmTypeL = FRAME_MULLION & iMlnType = MLN_TYPE2	then
				_xOffFrmL_Elev = _offsetL_ETC_Elev
			endif

			_xOffFrmR_Elev = _offsetR_PNL_Elev
			_xOffMlnR_Elev = _offsetM_PNL_Elev
			if	iFrmTypeR = FRAME_MULLION & iMlnType = MLN_TYPE2	then
				_xOffFrmR_Elev = _offsetR_ETC_Elev
			endif

			if	nMln < eps	then
				_xPosFrmL_Elev = _xOffFrmL_Elev
				_xPosFrmR_Elev = mlnGap[i] - _xOffFrmR_Elev
			else
				_xPosFrmL_Elev = _xOffMlnL_Elev
				_xPosFrmR_Elev = mlnGap[i] - _xOffMlnR_Elev

				if	i = 1	then
					_xPosFrmL_Elev = _xOffFrmL_Elev
				endif
				if	i = (nMln + 1)	then
					_xPosFrmR_Elev = mlnGap[i] - _xOffFrmR_Elev
				endif
			endif

			!	하부프레임
			if	bFrmB	then
				_frmType = iFrmTypeB
				_frmClass = HFRAME_CORNER
				_frmWdt = frmWdtB
				_gskWdt = gskWdtB

				gosub	"elev_hFrame"
			endif

			!	상부프레임
			if	bFrmT	then
				_frmType = iFrmTypeT
				_frmClass = HFRAME_CORNER
				_frmWdt = frmWdtT
				_gskWdt = gskWdtT

				addy	-_elevHgt
					muly	-1
						gosub	"elev_hFrame"
					del 1
				del 1
			endif

			!	트랜섬
			_bTrs = (nTrs > eps)
			if	_bTrs	then
				_frmClass = HFRAME_TRANSOM
				_frmWdt = trsWdt
				_gskWdt = trsGskWdt

				_trsLct = 0
				for	j = 1	to	nTrs
					_trsLct = _trsLct + trsGap[j]
					addy	-(_trsLct - trsWdt/2)/cos(aTilt)
						gosub	"elev_hFrame"
					del 1
				next	j
			endif

			!	분할 패널 내부 수평프레임
			_trsLct = 0
			for	j = 1	to	(nTrs + 1)
				_pnlType = iPnlType[i][j]
				if	j # 1	then
					_trsLct = _trsLct + trsGap[j - 1]
				endif

				_frmClass = HFRAME_TRANSOM
				_frmWdt = trsWdt
				_gskWdt = trsGskWdt

				if	_pnlType = PNL_SEP2_VERTICAL | _pnlType = PNL_SEP3_VERTICAL	then
					_frmLct = _trsLct + sep2_Vert[i][j]
					addy	-(_frmLct - trsWdt/2)/cos(aTilt)
						gosub	"elev_hFrame"
					del 1
				endif

				if	_pnlType = PNL_SEP3_VERTICAL	then
					_frmLct = _trsLct + sep3_Vert[i][j]
					addy	-(_frmLct - trsWdt/2)/cos(aTilt)
						gosub	"elev_hFrame"
					del 1
				endif
			next	j

			addx	mlnGap[i]
		next	i

		del (nMln + 1)

		!	분할 패널 내부 수직프레임
		!-----------------------------------------------------------------------------------------------
		for	i = 1	to	(nMln + 1)
			for	j = 1	to	(nTrs + 1)
				_pnlType = iPnlType[i][j]
				if	j = 1	then
					_trsLct = 0
				else
					_trsLct = _trsLct + trsGap[j - 1]
				endif
				_frmClass = VFRAME_MULLION

				_frmHgt = trsGap[j]
				if	nTrs < eps	then
					_offsetB = (frmWdtB + gskWdtB)/2
					if	iFrmTypeB = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetB = _offsetB + (frmWdtB - gskWdtB)/2
					_offsetT = (frmWdtT + gskWdtT)/2
					if	iFrmTypeT = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetT = _offsetT + (frmWdtT - gskWdtT)/2
				else
					if	j = 1	then
						_offsetB = (frmWdtB + gskWdtB)/2
						if	iFrmTypeB = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetB = _offsetB + (frmWdtB - gskWdtB)/2
						_offsetT = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetT = trsWdt/2
					endif
					if	j # 1 & j # (nTrs + 1)	then
						_offsetB = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetB = trsWdt/2
						_offsetT = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetT = trsWdt/2
					endif
					if	j = (nTrs +1)	then
						_offsetB = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetB = trsWdt/2
						_offsetT = (frmWdtT + gskWdtT)/2
						if	iFrmTypeT = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetT = _offsetT + (frmWdtT - gskWdtT)/2
					endif
				endif
				_frmHgt = _frmHgt - (_offsetB + _offsetT)
				_offsetB = (_offsetB + _trsLct)/cos(aTilt)
				_elevHgt = _frmHgt/cos(aTilt)

				if	_pnlType = PNL_SEP2_HORIZON | _pnlType = PNL_SEP3_HORIZON	then
					addx	sep2_Horz[i][j]
						addy	-_offsetB
							gosub	"elev_vFrame"
						del 1
					del 1
				endif

				if	_pnlType = PNL_SEP3_HORIZON	then
					addx	sep3_Horz[i][j]
						addy	-_offsetB
							gosub	"elev_vFrame"
						del 1
					del 1
				endif
			next	j

			addx	mlnGap[i]
		next	i

		del (nMln + 1)


		!	패널
		!-----------------------------------------------------------------------------------------------
		for	i = 1	to	(nMln + 1)
			for	j = 1	to	(nTrs + 1)
				_pnlType = iPnlType[i][j]
				_hingeType = iHingeType[i][j]

				_bSingle = (_pnlType = PNL_FIX | _pnlType = PNL_PROJECT | _pnlType = PNL_PROJECT_SMOKE | _pnlType = PNL_SPANDREL | \
							_pnlType = PNL_SPANDREL_SUB | _pnlType = PNL_SPANDREL_SUB2 | _pnlType = PNL_SPANDREL_SUB3 | _pnlType = PNL_GRILL)

				!	패널 너비
				_pnlWdt = 0
				_etcWdt = 0
				if	nMln < eps	then
					_pnlWdt = mlnGap[i] - (_offsetL_PNL_Elev + _offsetR_PNL_Elev)
					_etcWdt = mlnGap[i] - (_offsetL_ETC_Elev + _offsetR_ETC_Elev)
				else
					if	i = 1	then
						_pnlWdt = mlnGap[i] - (_offsetL_PNL_Elev + _offsetM_PNL_Elev)
						_etcWdt = mlnGap[i] - (_offsetL_ETC_Elev + _offsetM_ETC_Elev)
					endif
					if	i # 1 & i # (nMln + 1)	then
						_pnlWdt = mlnGap[i] - _offsetM_PNL_Elev*2
						_etcWdt = mlnGap[i] - _offsetM_ETC_Elev*2
					endif
					if	i = (nMln + 1)	then
						_pnlWdt = mlnGap[i] - (_offsetR_PNL_Elev + _offsetM_PNL_Elev)
						_etcWdt = mlnGap[i] - (_offsetR_ETC_Elev + _offsetM_ETC_Elev)
					endif
				endif

				!	패널 높이
				_pnlHgt = trsGap[j]
				_etcHgt = trsGap[j]
				if	j = 1	then
					_transY = 0
				else
					_transY = _transY + trsGap[j - 1]
				endif
				if	nTrs < eps	then
					_offsetB_PNL = (frmWdtB + gskWdtB)/2
					if	iFrmTypeB = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetB_PNL = frmWdtB
					_offsetT_PNL = (frmWdtT + gskWdtT)/2
					if	iFrmTypeT = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetT_PNL = frmWdtT
					_offsetB_ETC = frmWdtB
					_offsetT_ETC = frmWdtT
				else
					if	j = 1	then
						_offsetB_PNL = (frmWdtB + gskWdtB)/2
						if	iFrmTypeB = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetB_PNL = frmWdtB
						_offsetT_PNL = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetT_PNL = trsWdt/2
						_offsetB_ETC = frmWdtB
						_offsetT_ETC = trsWdt/2
					endif
					if	j # 1 & j # (nTrs + 1)	then
						_offsetB_PNL = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetB_PNL = trsWdt/2
						_offsetT_PNL = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetT_PNL = trsWdt/2
						_offsetB_ETC = trsWdt/2
						_offsetT_ETC = trsWdt/2
					endif
					if	j = (nTrs +1)	then
						_offsetB_PNL = trsGskWdt/2
						if	iTrsType = TRS_TYPE2	then	_offsetB_PNL = trsWdt/2
						_offsetT_PNL = (frmWdtT + gskWdtT)/2
						if	iFrmTypeT = FRAME_TRANSOM & iTrsType = TRS_TYPE2	then	_offsetT_PNL = frmWdtT
						_offsetB_ETC = trsWdt/2
						_offsetT_ETC = frmWdtT
					endif
				endif
				_pnlHgt = (_pnlHgt - (_offsetB_PNL + _offsetT_PNL))/cos(aTilt)
				_etcHgt = (_etcHgt - (_offsetB_ETC + _offsetT_ETC))/cos(aTilt)
				_offsetB_PNL = (_offsetB_PNL + _transY)/cos(aTilt)
				_offsetB_ETC = (_offsetB_ETC + _transY)/cos(aTilt)

				!	패널 x위치/높이 비율
				if	nMln < eps	then
					_xPosPnl = _offsetL_PNL_Elev
					_xPosEtc = _offsetL_ETC_Elev
				else
					if	i = 1	then
						_xPosPnl = _offsetL_PNL_Elev
						_xPosEtc = _offsetL_ETC_Elev
					else
						_xPosPnl = _offsetM_PNL_Elev
						_xPosEtc = _offsetM_ETC_Elev
					endif
				endif

				!	단일 창호 유형
				!-----------------------------------------------------------------------------------------------
				if	_bSingle	then
					gosub	"elev_pnl_Matrix"
				endif

				!	복합 창호 유형
				!-----------------------------------------------------------------------------------------------
				if	not(_bSingle)	then

					!	2분할 패널 유형(가로)
					if	_pnlType = PNL_SEP2_HORIZON	then
						!	변수정의
						_idx = iSepType[i][j]
						_pnlType1 = iSepType_2Horz[_idx][1]
						_pnlType2 = iSepType_2Horz[_idx][2]
						_hingeType1 = iHingeType_2Horz[_idx][1]
						_hingeType2 = iHingeType_2Horz[_idx][2]

						_pnlWdt1 = 0
						_pnlWdt2 = 0

						_xPosPnl1 = 0
						_xPosPnl2 = sep2_Horz[i][j] + _offsetM_PNL_Elev

						if	nMln < eps	then
							_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL_Elev + _offsetM_PNL_Elev)
							_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_PNL_Elev + _offsetM_PNL_Elev)

							_xPosPnl1 = _offsetL_PNL_Elev
						else
							if	i = 1	then
								_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL_Elev + _offsetM_PNL_Elev)
								_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2

								_xPosPnl1 = _offsetL_PNL_Elev
							endif
							if	i # 1 & i # (nMln + 1)	then
								_pnlWdt1 = sep2_Horz[i][j] - _offsetM_PNL_Elev*2
								_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2

								_xPosPnl1 = _offsetM_PNL_Elev
							endif
							if	i = (nMln + 1)	then
								_pnlWdt1 = sep2_Horz[i][j] - _offsetM_PNL_Elev*2
								_pnlWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_PNL_Elev + _offsetM_PNL_Elev)

								_xPosPnl1 = _offsetM_PNL_Elev
							endif
						endif

						_etcWdt1 = 0
						_etcWdt2 = 0

						_xPosEtc1 = 0
						_xPosEtc2 = sep2_Horz[i][j] + _offsetM_ETC_Elev

						if	nMln < eps	then
							_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC_Elev + _offsetM_ETC_Elev)
							_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_ETC_Elev + _offsetM_ETC_Elev)

							_xPosEtc1 = _offsetL_ETC_Elev
						else
							if	i = 1	then
								_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC_Elev + _offsetM_ETC_Elev)
								_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2

								_xPosEtc1 = _offsetL_ETC_Elev
							endif
							if	i # 1 & i # (nMln + 1)	then
								_etcWdt1 = sep2_Horz[i][j] - _offsetM_ETC_Elev*2
								_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2

								_xPosEtc1 = _offsetM_ETC_Elev
							endif
							if	i = (nMln + 1)	then
								_etcWdt1 = sep2_Horz[i][j] - _offsetM_ETC_Elev*2
								_etcWdt2 = (mlnGap[i] - sep2_Horz[i][j]) - (_offsetR_ETC_Elev + _offsetM_ETC_Elev)

								_xPosEtc1 = _offsetM_ETC_Elev
							endif
						endif

						!	1번 영역
						_pnlType = _pnlType1
						_hingeType = _hingeType1
						_pnlWdt = _pnlWdt1
						_etcWdt = _etcWdt1
						_xPosPnl = _xPosPnl1
						_xPosEtc = _xPosEtc1

						gosub	"elev_pnl_Matrix"

						!	2번 영역
						_pnlType = _pnlType2
						_hingeType = _hingeType2
						_pnlWdt = _pnlWdt2
						_etcWdt = _etcWdt2
						_xPosPnl = _xPosPnl2
						_xPosEtc = _xPosEtc2

						gosub	"elev_pnl_Matrix"
					endif

					!	3분할 패널 유형(가로)
					if	_pnlType = PNL_SEP3_HORIZON	then
						!	변수정의
						_idx = iSepType[i][j]
						_pnlType1 = iSepType_3Horz[_idx][1]
						_pnlType2 = iSepType_3Horz[_idx][2]
						_pnlType3 = iSepType_3Horz[_idx][3]
						_hingeType1 = iHingeType_3Horz[_idx][1]
						_hingeType2 = iHingeType_3Horz[_idx][2]
						_hingeType3 = iHingeType_3Horz[_idx][3]

						_pnlWdt1 = 0
						_pnlWdt2 = 0
						_pnlWdt3 = 0

						_xPosPnl1 = 0
						_xPosPnl2 = sep2_Horz[i][j] + _offsetM_PNL_Elev
						_xPosPnl3 = sep3_Horz[i][j] + _offsetM_PNL_Elev

						if	nMln < eps	then
							_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL_Elev + _offsetM_PNL_Elev)
							_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2
							_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_PNL_Elev + _offsetM_PNL_Elev)

							_xPosPnl1 = _offsetL_PNL_Elev
						else
							if	i = 1	then
								_pnlWdt1 = sep2_Horz[i][j] - (_offsetL_PNL_Elev + _offsetM_PNL_Elev)
								_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2
								_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - _offsetM_PNL_Elev*2

								_xPosPnl1 = _offsetL_PNL_Elev
							endif
							if	i # 1 & i # (nMln + 1)	then
								_pnlWdt1 = sep2_Horz[i][j] - _offsetM_PNL_Elev*2
								_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2
								_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - _offsetM_PNL_Elev*2

								_xPosPnl1 = _offsetM_PNL_Elev
							endif
							if	i = (nMln + 1)	then
								_pnlWdt1 = sep2_Horz[i][j] - _offsetM_PNL_Elev*2
								_pnlWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_PNL_Elev*2
								_pnlWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_PNL_Elev + _offsetM_PNL_Elev)

								_xPosPnl1 = _offsetM_PNL_Elev
							endif
						endif

						_etcWdt1 = 0
						_etcWdt2 = 0
						_etcWdt3 = 0

						_xPosEtc1 = 0
						_xPosEtc2 = sep2_Horz[i][j] + _offsetM_ETC_Elev
						_xPosEtc3 = sep3_Horz[i][j] + _offsetM_ETC_Elev

						if	nMln < eps	then
							_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC_Elev + _offsetM_ETC_Elev)
							_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2
							_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_ETC_Elev + _offsetM_ETC_Elev)

							_xPosEtc1 = _offsetL_ETC_Elev
						else
							if	i = 1	then
								_etcWdt1 = sep2_Horz[i][j] - (_offsetL_ETC_Elev + _offsetM_ETC_Elev)
								_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2
								_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - _offsetM_ETC_Elev*2

								_xPosEtc1 = _offsetL_ETC_Elev
							endif
							if	i # 1 & i # (nMln + 1)	then
								_etcWdt1 = sep2_Horz[i][j] - _offsetM_ETC_Elev*2
								_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2
								_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - _offsetM_ETC_Elev*2

								_xPosEtc1 = _offsetM_ETC_Elev
							endif
							if	i = (nMln + 1)	then
								_etcWdt1 = sep2_Horz[i][j] - _offsetM_ETC_Elev*2
								_etcWdt2 = (sep3_Horz[i][j] - sep2_Horz[i][j]) - _offsetM_ETC_Elev*2
								_etcWdt3 = (mlnGap[i] - sep3_Horz[i][j]) - (_offsetR_ETC_Elev + _offsetM_ETC_Elev)

								_xPosEtc1 = _offsetM_ETC_Elev
							endif
						endif

						!	1번 영역
						_pnlType = _pnlType1
						_hingeType = _hingeType1
						_pnlWdt = _pnlWdt1
						_etcWdt = _etcWdt1
						_xPosPnl = _xPosPnl1
						_xPosEtc = _xPosEtc1

						gosub	"elev_pnl_Matrix"

						!	2번 영역
						_pnlType = _pnlType2
						_hingeType = _hingeType2
						_pnlWdt = _pnlWdt2
						_etcWdt = _etcWdt2
						_xPosPnl = _xPosPnl2
						_xPosEtc = _xPosEtc2

						gosub	"elev_pnl_Matrix"

						!	3번 영역
						_pnlType = _pnlType3
						_hingeType = _hingeType3
						_pnlWdt = _pnlWdt3
						_etcWdt = _etcWdt3
						_xPosPnl = _xPosPnl3
						_xPosEtc = _xPosEtc3

						gosub	"elev_pnl_Matrix"
					endif

					!	2분할 패널 유형(세로)
					if	_pnlType = PNL_SEP2_VERTICAL	then
						!	변수정의
						_idx = iSepType[i][j]
						_pnlType1 = iSepType_2Vert[1][_idx]
						_pnlType2 = iSepType_2Vert[2][_idx]
						_hingeType1 = iHingeType_2Vert[1][_idx]
						_hingeType2 = iHingeType_2Vert[2][_idx]

						_pnlHgt1 = 0
						_pnlHgt2 = 0

						_etcHgt1 = 0
						_etcHgt2 = 0

						if	nTrs < eps	then
							_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
							_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

							_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
							_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - (frmWdtT + trsWdt/2)
						else
							if	j = 1	then
								_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
								_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsGskWdt

								_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
								_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsWdt
							endif
							if	j # 1 & j # (nTrs + 1)	then
								_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
								_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsGskWdt

								_etcHgt1 = sep2_Vert[i][j] - trsWdt
								_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - trsWdt
							endif
							if	j = (nTrs + 1)	then
								_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
								_pnlHgt2 = (trsGap[j] - sep2_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

								_etcHgt1 = sep2_Vert[i][j] - trsWdt
								_etcHgt2 = (trsGap[j] - sep2_Vert[i][j]) - (frmWdtT + trsWdt/2)
							endif
						endif

						_pnlHgt1 = _pnlHgt1/cos(aTilt)
						_pnlHgt2 = _pnlHgt2/cos(aTilt)

						_etcHgt1 = _etcHgt1/cos(aTilt)
						_etcHgt2 = _etcHgt2/cos(aTilt)

						_offsetB_PNL1 = _offsetB_PNL
						_offsetB_PNL2 = (sep2_Vert[i][j] + trsGskWdt/2 + _transY)/cos(aTilt)

						_offsetB_ETC1 = _offsetB_ETC
						_offsetB_ETC2 = (sep2_Vert[i][j] + trsWdt/2 + _transY)/cos(aTilt)

						!	1번 영역
						_pnlType = _pnlType1
						_hingeType = _hingeType1
						_pnlHgt = _pnlHgt1
						_etcHgt = _etcHgt1
						_offsetB_PNL = _offsetB_PNL1
						_offsetB_ETC = _offsetB_ETC1

						gosub	"elev_pnl_Matrix"

						!	2번 영역
						_pnlType = _pnlType2
						_hingeType = _hingeType2
						_pnlHgt = _pnlHgt2
						_etcHgt = _etcHgt2
						_offsetB_PNL = _offsetB_PNL2
						_offsetB_ETC = _offsetB_ETC2

						gosub	"elev_pnl_Matrix"
					endif

					!	3분할 패널 유형(세로)
					if	_pnlType = PNL_SEP3_VERTICAL	then
						!	변수정의
						_idx = iSepType[i][j]
						_pnlType1 = iSepType_3Vert[1][_idx]
						_pnlType2 = iSepType_3Vert[2][_idx]
						_pnlType3 = iSepType_3Vert[3][_idx]
						_hingeType1 = iHingeType_3Vert[1][_idx]
						_hingeType2 = iHingeType_3Vert[2][_idx]
						_hingeType3 = iHingeType_3Vert[3][_idx]

						_pnlHgt1 = 0
						_pnlHgt2 = 0
						_pnlHgt3 = 0

						_etcHgt1 = 0
						_etcHgt2 = 0
						_etcHgt3 = 0

						if	nTrs < eps	then
							_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
							_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
							_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

							_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
							_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
							_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - (frmWdtT + trsWdt/2)
						else
							if	j = 1	then
								_pnlHgt1 = sep2_Vert[i][j] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
								_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
								_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsGskWdt

								_etcHgt1 = sep2_Vert[i][j] - (frmWdtB + trsWdt/2)
								_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
								_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsWdt
							endif
							if	j # 1 & j # (nTrs + 1)	then
								_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
								_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
								_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsGskWdt

								_etcHgt1 = sep2_Vert[i][j] - trsWdt
								_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
								_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - trsWdt
							endif
							if	j = (nTrs + 1)	then
								_pnlHgt1 = sep2_Vert[i][j] - trsGskWdt
								_pnlHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsGskWdt
								_pnlHgt3 = (trsGap[j] - sep3_Vert[i][j]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)

								_etcHgt1 = sep2_Vert[i][j] - trsWdt
								_etcHgt2 = (sep3_Vert[i][j] - sep2_Vert[i][j]) - trsWdt
								_etcHgt3 = (trsGap[j] - sep3_Vert[i][j]) - (frmWdtT + trsWdt/2)
							endif
						endif

						_pnlHgt1 = _pnlHgt1/cos(aTilt)
						_pnlHgt2 = _pnlHgt2/cos(aTilt)
						_pnlHgt3 = _pnlHgt3/cos(aTilt)

						_etcHgt1 = _etcHgt1/cos(aTilt)
						_etcHgt2 = _etcHgt2/cos(aTilt)
						_etcHgt3 = _etcHgt3/cos(aTilt)

						_offsetB_PNL1 = _offsetB_PNL
						_offsetB_PNL2 = (sep2_Vert[i][j] + trsGskWdt/2 + _transY)/cos(aTilt)
						_offsetB_PNL3 = (sep3_Vert[i][j] + trsGskWdt/2 + _transY)/cos(aTilt)

						_offsetB_ETC1 = _offsetB_ETC
						_offsetB_ETC2 = (sep2_Vert[i][j] + trsWdt/2 + _transY)/cos(aTilt)
						_offsetB_ETC3 = (sep3_Vert[i][j] + trsWdt/2 + _transY)/cos(aTilt)

						!	1번 영역
						_pnlType = _pnlType1
						_hingeType = _hingeType1
						_pnlHgt = _pnlHgt1
						_etcHgt = _etcHgt1
						_offsetB_PNL = _offsetB_PNL1
						_offsetB_ETC = _offsetB_ETC1

						gosub	"elev_pnl_Matrix"

						!	2번 영역
						_pnlType = _pnlType2
						_hingeType = _hingeType2
						_pnlHgt = _pnlHgt2
						_etcHgt = _etcHgt2
						_offsetB_PNL = _offsetB_PNL2
						_offsetB_ETC = _offsetB_ETC2

						gosub	"elev_pnl_Matrix"

						!	3번 영역
						_pnlType = _pnlType3
						_hingeType = _hingeType3
						_pnlHgt = _pnlHgt3
						_etcHgt = _etcHgt3
						_offsetB_PNL = _offsetB_PNL3
						_offsetB_ETC = _offsetB_ETC3

						gosub	"elev_pnl_Matrix"
					endif

				endif


			next	j

			addx	mlnGap[i]
		next	i

	del 1
	del 1
	del 1
endif




end



!-----------------------------------------------------------------------------------------------
"vFrame":	!	수직프레임
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmSectPen
	material	frmMat

	!	비율
	_ratioB = 0
	_ratioT = 1
	if	not(bFrmB)	then
		_ratioB = frmWdtB/ctwHgt
	endif
	if	not(bFrmT)	then
		_ratioT = (ctwHgt - frmWdtT)/ctwHgt
	endif

	!	벡터
	_vx = 0
	_vy = ctwHgt*tan(aTilt)
	_vz = ctwHgt

	!	자르기
	_nCut = 0
	if	not(bFrmB)	then
		addz	frmWdtB
			cutplane	1,	1,	0,	1	:	_nCut = _nCut + 1
		del 1
	endif
	if	not(bFrmT)	then
		addz	ctwHgt - frmWdtT
			cutplane	1,	1,	0,	0	:	_nCut = _nCut + 1
		del 1
	endif

		!	형태
		if	(_frmType = FRAME_BOUNDARY & _frmClass = VFRAME_CORNER)	then
			put	0,						-(_frmThk + gskThk),	0,
				0,						0,						0,
				(_frmWdt + _gskWdt)/2,	0,						0,
				(_frmWdt + _gskWdt)/2,	-gskThk,				0,
				_frmWdt,				-gskThk,				0,
				_frmWdt,				-(_frmThk + gskThk),	0
		endif

		if	(_frmType = FRAME_MULLION & _frmClass = VFRAME_CORNER) | _frmClass = VFRAME_MULLION	then
			if	iMlnType = MLN_TYPE1	then
				put	-_frmWdt/2,	-(_frmThk + gskThk),	0,
					-_frmWdt/2,	-gskThk,				0,
					-_gskWdt/2,	-gskThk,				0,
					-_gskWdt/2,	0,						0,
					_gskWdt/2,	0,						0,
					_gskWdt/2,	-gskThk,				0,
					_frmWdt/2,	-gskThk,				0,
					_frmWdt/2,	-(_frmThk + gskThk),	0
			endif

			if	iMlnType = MLN_TYPE2	then
				put	-_frmWdt/2,	-(_frmThk + gskThk),	0,
					-_frmWdt/2,	-gskThk,				0,
					-_gskWdt/2,	-gskThk,				0,
					-_gskWdt/2,	-gskCapThk,				0,
					-_frmWdt/2,	-gskCapThk,				0,
					-_frmWdt/2,	0,						0,
					_frmWdt/2,	0,						0,
					_frmWdt/2,	-gskCapThk,				0,
					_gskWdt/2,	-gskCapThk,				0,
					_gskWdt/2,	-gskThk,				0,
					_frmWdt/2,	-gskThk,				0,
					_frmWdt/2,	-(_frmThk + gskThk),	0
			endif
		endif

		extrude	nsp/3,	_vx,	_vy,	_vz,	1+2+4+16+32,	use(nsp)

	if	_nCut > eps	then
		for	c = 1	to	_nCut
			cutend
		next	c
	endif

	for	h = 1	to	(nsp/3)
		hotspot	use(3),	unID	:	unID = unID  + 1

		add	_vx*_ratioB,	_vy*_ratioB,	_vz*_ratioB
			hotspot	use(3),	unID	:	unID = unID  + 1
		del 1

		add	_vx*_ratioT,	_vy*_ratioT,	_vz*_ratioT
			hotspot	use(3),	unID	:	unID = unID  + 1
		del 1

		add	_vx,	_vy,	_vz
			hotspot	get(3),	unID	:	unID = unID  + 1
		del 1
	next	h

return

!-----------------------------------------------------------------------------------------------
"hFrame":	!	수평프레임
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmSectPen
	material	frmMat

	!	벡터
	_hx = 0
	_hy = _frmWdt*tan(aTilt)
	_hz = _frmWdt

	!	형태
	for	i = 1	to	nMln + 1
		roty	-90
			_nCut = 0

			if	(_frmType = FRAME_BOUNDARY & _frmClass = HFRAME_CORNER)	then
				put	_cutHgt3,	_cutWdt3 - gskThk,
					_cutHgt3,	_cutWdt3,
					_cutHgt4,	_cutWdt4,
					_cutHgt4,	_cutWdt4 - gskThk

				cutpoly	nsp/2,	get(nsp)	:	_nCut = _nCut + 1
			endif

			if	(_frmType = FRAME_TRANSOM & _frmClass = HFRAME_CORNER) | _frmClass = HFRAME_TRANSOM	then
				if	iTrsType = TRS_TYPE1	then	_bGskCap = 0
				if	iTrsType = TRS_TYPE2	then	_bGskCap = 1

				put	_cutHgt1,	_cutWdt1 - gskThk,
					_cutHgt1,	_cutWdt1 - gskCapThk*_bGskCap,
					_cutHgt2,	_cutWdt2 - gskCapThk*_bGskCap,
					_cutHgt2,	_cutWdt2 - gskThk

				cutpoly	nsp/2,	get(nsp)	:	_nCut = _nCut + 1

				put	_cutHgt3,	_cutWdt3 - gskThk,
					_cutHgt3,	_cutWdt3 - gskCapThk*_bGskCap,
					_cutHgt4,	_cutWdt4 - gskCapThk*_bGskCap,
					_cutHgt4,	_cutWdt4 - gskThk

				cutpoly	nsp/2,	get(nsp)	:	_nCut = _nCut + 1
			endif
		del 1

		put	0,			-(_frmThk + gskThk),	0,
			0,			0,						0,
			mlnGap[i],	0,						0,
			mlnGap[i],	-(_frmThk + gskThk),	0

		extrude	nsp/3,	_hx,	_hy,	_hz,	1+2+4+16+32,	get(nsp)

		for	c = 1	to	_nCut
			cutend
		next	c

		addx	mlnGap[i]
	next	i

	del nMln + 1

return

!-----------------------------------------------------------------------------------------------
"pnl_Matrix":	!	패널 매트릭스
!-----------------------------------------------------------------------------------------------
	!	유리
	if	not(_pnlType = PNL_GRILL) & not(_pnlType = PNL_OPEN)	then
		add	_dx*_pnlRatio,	_dy*_pnlRatio,	_dz*_pnlRatio
			addx	_xPosPnl
				gosub	"pnlWin"
			del 1
		del 1
	endif

	!	텍스트
	if	_pnlType = PNL_FIX | _pnlType = PNL_SPANDREL | _pnlType = PNL_SPANDREL_SUB | \
		_pnlType = PNL_SPANDREL_SUB2 | _pnlType = PNL_SPANDREL_SUB3 | _pnlType = PNL_PROJECT_SMOKE	then
		if	_pnlType = PNL_FIX | _pnlType = PNL_SPANDREL | _pnlType = PNL_SPANDREL_SUB | \
			_pnlType = PNL_SPANDREL_SUB2 | _pnlType = PNL_SPANDREL_SUB3	then
			_stFix = "F"
			_bCircle = 0
			_bText = 0
			if	bFixTxt	then
				_bText = 1
			endif
		else
			_stFix = "배"
			_bCircle = 1
			_bText = 0
			if	bSmkTxt	then
				_bText = 1
			endif
		endif

		if	_bText	then
			add	_dx*_pnlRatio,	_dy*_pnlRatio,	_dz*_pnlRatio
				add	_xPosPnl + _pnlWdt/2,	-gskThk + _pnlY/2,	_pnlZ/2
					gosub	"pnlTxt"
				del 1
			del 1
		endif
	endif

	!	열림표현
	if	_pnlType = PNL_PROJECT | _pnlType = PNL_PROJECT_SMOKE	then
		add	_dx*_pnlRatio,	_dy*_pnlRatio,	_dz*_pnlRatio
			addx	_xPosPnl
				addy	-gskThk
					gosub	"pnlOpen"
				del 1

				addy	-(gskThk - glsThk)
					gosub	"pnlOpen"
				del 1
			del 1
		del 1
	endif

	!	단열재
	if	_pnlType = PNL_SPANDREL | _pnlType = PNL_SPANDREL_SUB | _pnlType = PNL_SPANDREL_SUB2 | _pnlType = PNL_SPANDREL_SUB3	then
		add	_dx*_etcRatio,	_dy*_etcRatio,	_dz*_etcRatio
			addx	_xPosEtc
				gosub	"pnlIns"
			del 1
		del 1
	endif

	!	그릴
	if	_pnlType = PNL_GRILL	then
		add	_dx*_etcRatio,	_dy*_etcRatio,	_dz*_etcRatio
			addx	_xPosEtc
				gosub	"pnlGrl"
			del 1
		del 1
	endif

return

!-----------------------------------------------------------------------------------------------
"pnl_vFrame":	!	패널 수직프레임
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmSectPen
	material	frmMat

	!	본체
	add	_dx*_etcRatio + _xPosFrm,	_dy*_etcRatio,	_dz*_etcRatio
		put	-mlnWdt/2,		-gskThk,			0,
			-mlnWdt/2,		-(gskThk + mlnThk),	0,
			mlnWdt/2,		-(gskThk + mlnThk),	0,
			mlnWdt/2,		-gskThk,			0

		extrude	nsp/3,	_etcX,	_etcY,	_etcZ,	1+2+4+16+32,	get(nsp)
	del 1

	!	개스킷
	add	_dx*_pnlRatio + _xPosFrm,	_dy*_pnlRatio,	_dz*_pnlRatio
		if	iMlnType = MLN_TYPE1	then
			put	-mlnGskWdt/2,	0,					0,
				-mlnGskWdt/2,	-gskThk,			0,
				mlnGskWdt/2,	-gskThk,			0,
				mlnGskWdt/2,	0,					0
		endif
		if	iMlnType = MLN_TYPE2	then
			put	-mlnWdt/2,		0,					0,
				-mlnWdt/2,		-gskCapThk,			0,
				-mlnGskWdt/2,	-gskCapThk,			0,
				-mlnGskWdt/2,	-gskThk,			0,
				mlnGskWdt/2,	-gskThk,			0,
				mlnGskWdt/2,	-gskCapThk,			0,
				mlnWdt/2,		-gskCapThk,			0,
				mlnWdt/2,		0,					0
		endif

		extrude	nsp/3,	_pnlX,	_pnlY,	_pnlZ,	1+2+4+16+32,	get(nsp)
	del 1

return

!-----------------------------------------------------------------------------------------------
"pnl_hFrame":	!	패널 수평프레임
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmSectPen
	material	frmMat

	add	_dx*_frmRatio,	_dy*_frmRatio,	_dz*_frmRatio
		_nCut = 0

		roty	-90
			if	iTrsType = TRS_TYPE1	then	_bGskCap = 0
			if	iTrsType = TRS_TYPE2	then	_bGskCap = 1
			_cutHgt = (trsWdt - trsGskWdt)/2
			_cutWdt = _cutHgt*tan(aTilt)
			put	0,			-gskThk,
				0,			-gskCapThk*_bGskCap,
				_cutHgt,	_cutWdt - gskCapThk*_bGskCap,
				_cutHgt,	_cutWdt - gskThk

			cutpoly	nsp/2,	use(nsp)	:	_nCut = _nCut + 1
			add	(trsWdt + trsGskWdt)/2,	(trsWdt + trsGskWdt)/2*tan(aTilt),	0
				cutpoly	nsp/2,	get(nsp)	:	_nCut = _nCut + 1
			del 1
		del 1

			put	_xPosPnl,			0,					0,
				_xPosPnl,			-gskThk,			0,
				_xPosEtc,			-gskThk,			0,
				_xPosEtc,			-(gskThk + trsThk),	0,
				_xPosEtc + _etcWdt,	-(gskThk + trsThk),	0,
				_xPosEtc + _etcWdt,	-gskThk,			0,
				_xPosPnl + _pnlWdt,	-gskThk,			0,
				_xPosPnl + _pnlWdt,	0,					0

			extrude	nsp/3,	0,	trsWdt*tan(aTilt),	trsWdt,	1+2+4+16+32,	get(nsp)

		for	c = 1	to	_nCut
			cutend
		next	c

	del 1

return

!-----------------------------------------------------------------------------------------------
"pnlWin":	!	패널 : 유리
!-----------------------------------------------------------------------------------------------
	pen			glsElevPen
	sect_fill	glsFill,	glsBackPen,	glsFillPen,	glsSectPen
	material	glsMat
	if	_pnlType = PNL_SPANDREL			then	material	spdGlsMat_1
	if	_pnlType = PNL_SPANDREL_SUB		then	material	spdGlsMat_2
	if	_pnlType = PNL_SPANDREL_SUB2	then	material	spdGlsMat_3
	if	_pnlType = PNL_SPANDREL_SUB3	then	material	spdGlsMat_4

	put	0,			-(gskThk - glsThk),	0,
		0,			-gskThk,			0,
		_pnlWdt,	-gskThk,			0,
		_pnlWdt,	-(gskThk - glsThk),	0

	addy	glsLct
		extrude	nsp/3,	_pnlX,	_pnlY,	_pnlZ,	1+2+4+16+32,	get(nsp)
	del 1

return

!-----------------------------------------------------------------------------------------------
"pnlTxt":	!	패널 : 텍스트
!-----------------------------------------------------------------------------------------------
	pen			txtPen
	material	txtMat
	style		"txtSty_Fix"

	_bSym = -1 + 2*bSymTxt

	if	GLOB_VIEW_TYPE = 4 | GLOB_VIEW_TYPE = 5	then
		addy	glsLct
			mulx	_bSym
				rotx	90 - aTilt
					text	eps,	0,	_stFix
					if	_bCircle	then
						model	wire
							circle	txtSize/1000
						model	solid
					endif
				del 1

				addy	glsThk + eps
					rotx	90 - aTilt
						text	eps,	0,	_stFix
						if	_bCircle	then
							model	wire
								circle	txtSize/1000
							model	solid
						endif
					del 1
				del 1
			del 1
		del 1
	endif

return

!-----------------------------------------------------------------------------------------------
"pnlOpen":	!	패널 : 열림표현
!-----------------------------------------------------------------------------------------------
	pen	oplinePen

	if	not(GLOB_VIEW_TYPE = 2)	then
		addy	glsLct
			if	_hingeType = HINGE_TOP | _hingeType = HINGE_TOP_LEFT | _hingeType = HINGE_TOP_RIGHT	then
				lin_	0,			0,		0,
						_pnlWdt/2,	_pnlY,	_pnlZ

				lin_	_pnlWdt/2,	_pnlY,	_pnlZ,
						_pnlWdt,	0,		0
			endif

			if	_hingeType = HINGE_BOTTOM | _hingeType = HINGE_BOTTOM_LEFT | _hingeType = HINGE_BOTTOM_RIGHT	then
				lin_	0,			_pnlY,	_pnlZ,
						_pnlWdt/2,	0,		0

				lin_	_pnlWdt/2,	0,		0,
						_pnlWdt,	_pnlY,	_pnlZ
			endif

			if	_hingeType = HINGE_LEFT | _hingeType = HINGE_TOP_LEFT | _hingeType = HINGE_BOTTOM_LEFT	then
				lin_	_pnlWdt,	0,			0,
						0,			_pnlY/2,	_pnlZ/2

				lin_	0,			_pnlY/2,	_pnlZ/2,
						_pnlWdt,	_pnlY,		_pnlZ
			endif

			if	_hingeType = HINGE_RIGHT | _hingeType = HINGE_TOP_RIGHT | _hingeType = HINGE_BOTTOM_RIGHT	then
				lin_	0,			0,			0,
						_pnlWdt,	_pnlY/2,	_pnlZ/2

				lin_	_pnlWdt,	_pnlY/2,	_pnlZ/2,
						0,			_pnlY,		_pnlZ
			endif
		del 1
	endif
return

!-----------------------------------------------------------------------------------------------
"pnlIns":	!	패널 : 단열재
!-----------------------------------------------------------------------------------------------
	!	단열재
	pen			insElevPen
	sect_fill	insFill,	insBackPen,	insFillPen,	insSectPen
	if	_pnlType = PNL_SPANDREL	then
		material	insMat_1
		_insThk = insThk_1
	endif
	if	_pnlType = PNL_SPANDREL_SUB	then
		material	insMat_2
		_insThk = insThk_2
	endif
	if	_pnlType = PNL_SPANDREL_SUB2	then
		material	insMat_3
		_insThk = insThk_3
	endif
	if	_pnlType = PNL_SPANDREL_SUB3	then
		material	insMat_4
		_insThk = insThk_4
	endif

	if	_insThk > eps	then
		!	단열 철판 두께 변수 정의
		_offsetIns = 0
		_spdFrmThk = 0
		if	bSpdFrm	then
			_offsetIns = 0.006
			_spdFrmThk = spdFrmThk
		endif

		_transX_Ins = 0
		_transY_Ins = (_offsetIns + _spdFrmThk)*tan(aTilt)
		_transZ_Ins = (_offsetIns + _spdFrmThk)

		_insX = 0
		_insY = (_etcHgt - (_offsetIns + _spdFrmThk)*2)*tan(aTilt)
		_insZ = (_etcHgt - (_offsetIns + _spdFrmThk)*2)

		_transX_InsFrm = 0
		_transY_InsFrm = _offsetIns*tan(aTilt)
		_transZ_InsFrm = _offsetIns

		_insFrmX = 0
		_insFrmY = (_etcHgt - _offsetIns*2)*tan(aTilt)
		_insFrmZ = (_etcHgt - _offsetIns*2)

		put	(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk) + _spdFrmThk,			15,
			(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk) + _insThk - _spdFrmThk,	15,
			_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + _insThk - _spdFrmThk,	15,
			_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + _spdFrmThk,			15

		add	_transX_Ins,	_transY_Ins,	_transZ_Ins
			extrude	nsp/3,	_insX,	_insY,	_insZ,	1+2+4+16+32,	get(nsp)
		del 1

		!	단열 철판
		sect_fill	65,	insBackPen,	insFillPen,	insSectPen
		material	spdFrmMat

		if	bSpdFrm	then
			!	Cut
			roty	-90
				put	(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk) + (_offsetIns + _spdFrmThk)*tan(aTilt) + _spdFrmThk,
					(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk) + (_offsetIns + _spdFrmThk)*tan(aTilt) + _insThk - _spdFrmThk,
					_etcHgt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + (_etcHgt - (_offsetIns + _spdFrmThk))*tan(aTilt) + _insThk - _spdFrmThk,
					_etcHgt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + (_etcHgt - (_offsetIns + _spdFrmThk))*tan(aTilt) + _spdFrmThk

				! poly	nsp/2,	use(nsp)
				cutpoly	nsp/2,	get(nsp)
			del 1

			!	본체
			put	(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk),				15,
				(_offsetIns + _spdFrmThk),				-(_minFrmThk + gskThk) + _insThk,	15,
				_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + _insThk,	15,
				_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk),				15

			add	_transX_InsFrm,	_transY_InsFrm,	_transZ_InsFrm
				extrude	nsp/3,	_insFrmX,	_insFrmY,	_insFrmZ,	1+2+4+16+32,	get(nsp)
			del 1

			!	Cutend
			cutend

			!	옆 덮개
			put	_offsetIns,					-(_minFrmThk + gskThk),				15,
				_offsetIns,					-(_minFrmThk + gskThk) + _insThk,	15,
				(_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + _insThk,	15,
				(_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk),				15

			add	_transX_InsFrm,	_transY_InsFrm,	_transZ_InsFrm
				extrude	nsp/3,	_insFrmX,	_insFrmY,	_insFrmZ,	1+2+4+16+32,	get(nsp)
			del 1

			put	_etcWdt - _offsetIns,					-(_minFrmThk + gskThk),				15,
				_etcWdt - _offsetIns,					-(_minFrmThk + gskThk) + _insThk,	15,
				_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk) + _insThk,	15,
				_etcWdt - (_offsetIns + _spdFrmThk),	-(_minFrmThk + gskThk),				15

			add	_transX_InsFrm,	_transY_InsFrm,	_transZ_InsFrm
				extrude	nsp/3,	_insFrmX,	_insFrmY,	_insFrmZ,	1+2+4+16+32,	get(nsp)
			del 1
		endif

		!	단열재 해치
		if	GLOB_VIEW_TYPE = 4	then
			sect_fill	insFill,	insBackPen,	insFillPen,	insHtcPen

			!	해치 전체 길이
			_insHtcLth = _etcHgt/cos(aTilt) + _insThk*sin(aTilt)
			_insHtcWdt = _etcWdt

			!	해치 변수 정의
			_modWdt = ((_insThk - _spdFrmThk*2)*cos(aTilt) - eps*2)/2
			_modUnit = _modWdt/2

			_nMod = int(_insHtcLth/_modWdt)
			_nMod = _nMod + 2

			_insOff = 0
			if	aTilt < -eps	then	_insOff = _insThk*sin(aTilt)

			addy	-(_minFrmThk + gskThk) + _spdFrmThk + eps

				!	해치 자르기
				_nCut = 0
				addz	(_offsetIns + _spdFrmThk)
					cutplane	1,	1,	0,	1	:	_nCut = _nCut + 1
				del 1
				addz	_etcHgt - (_offsetIns + _spdFrmThk)
					cutplane	1,	1,	0,	0	:	_nCut = _nCut + 1
				del 1

				!	해치 그리기
				rotx	-aTilt
					addz	_insOff
						roty	-90
							for	m = 1	to	_nMod
								put	0,			0,			0,
									0,			_modUnit,	900,
									0,			90,			4000,
									_modUnit,	_modUnit,	0,
									0,			_modUnit*3,	0,
									_modUnit,	_modUnit*3,	900,
									0,			-180,		4000,
									_modWdt,	_modUnit*3,	0,
									_modUnit,	_modUnit,	0,
									_modWdt,	_modUnit,	900,
									0,			90,			4000

								extrude	nsp/3,	0,	0,	-_insHtcWdt,	0,	get(nsp)

								addx	_modWdt
							next	m

							del	_nMod
						del 1
					del 1
				del 1
			del 1

			for	c = 1	to	_nCut
				cutend
			next	c
		endif
	endif

return

!-----------------------------------------------------------------------------------------------
"pnlGrl":	!	패널 : 그릴
!-----------------------------------------------------------------------------------------------
	pen			grlElevPen
	sect_fill	grlFill,	grlBackPen,	grlFillPen,	grlSectPen
	material	grlMat

	!	변수 정의
	_grlLth = _etcHgt/cos(aTilt)
	_grlWdt = _etcWdt

	_nGrl = int(_grlLth/grlGap)
	_rGrl = (_grlLth MOD grlGap)/2

	!	그릴 형태
	if	not(GLOB_FEEDBACK_MODE)	then
		addy	-(gskThk + grlGap/2)

			!	날개
			for	m = 1	to	_nGrl
				_modLct = grlGap*(m - 1) + grlGap/2
				_modRatio = (_modLct + _rGrl)/_grlLth

				add	_etcX*_modRatio,	_etcY*_modRatio,	_etcZ*_modRatio
					if	GLOB_VIEW_TYPE = 5	then
						lin_	0,			0,	0,
								_grlWdt,	0,	0
					else
						rotx	-(aGrl + aTilt)
							put	0,			grlGap/2,	15,
								0,			-grlGap/2,	15,
								_grlWdt,	-grlGap/2,	15,
								_grlWdt,	grlGap/2,	15

							prism_	nsp/3,	grlThk/2,	use(nsp)
							prism_	nsp/3,	-grlThk/2,	get(nsp)
						del 1
					endif
				del 1
			next	m

			!	틈 막음(하부)
			_btmLct = -grlGap/2
			_btmRatio = (_btmLct + _rGrl)/_grlLth

			cutplane	0,	0,	0,	1

				add	_etcX*_btmRatio,	_etcY*_btmRatio,	_etcZ*_btmRatio
					if	GLOB_VIEW_TYPE = 5	then
					else
						rotx	-(90 + aTilt)
							put	0,			grlGap/2,	15,
								0,			-grlGap/2,	15,
								_grlWdt,	-grlGap/2,	15,
								_grlWdt,	grlGap/2,	15

							prism_	nsp/3,	grlThk/2,	use(nsp)
							prism_	nsp/3,	-grlThk/2,	get(nsp)
						del 1
					endif
				del 1

			cutend

			!	틈 막음(상부)
			_topLct = grlGap*_nGrl + grlGap/2
			_topRatio = (_topLct + _rGrl)/_grlLth

			addz	_etcHgt
				cutplane	0,	0, 	0,	0
			del 1

				add	_etcX*_topRatio,	_etcY*_topRatio,	_etcZ*_topRatio
					rotx	-(90 + aTilt)
						put	0,			grlGap/2,	15,
							0,			-grlGap/2,	15,
							_grlWdt,	-grlGap/2,	15,
							_grlWdt,	grlGap/2,	15

						prism_	nsp/3,	grlThk/2,	use(nsp)
						prism_	nsp/3,	-grlThk/2,	get(nsp)
					del 1
				del 1

			cutend
		del 1
	endif

return

!-----------------------------------------------------------------------------------------------
"elev_vFrame":
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	material	frmMat

	if	(_frmType = FRAME_BOUNDARY & _frmClass = VFRAME_CORNER)	then
		put	0,						0,			15,
			0,						-_elevHgt,	15,
			(_frmWdt + _gskWdt)/2,	-_elevHgt,	15,
			(_frmWdt + _gskWdt)/2,	0,			15
	endif
	if	(_frmType = FRAME_MULLION & _frmClass = VFRAME_CORNER) | _frmClass = VFRAME_MULLION	then
		if	iMlnType = MLN_TYPE1	then
			put	-_gskWdt/2,	0,			15,
				-_gskWdt/2,	-_elevHgt,	15,
				_gskWdt/2,	-_elevHgt,	15,
				_gskWdt/2,	0,			15
		endif
		if	iMlnType = MLN_TYPE2	then
			put	-_frmWdt/2,	0,			15,
				-_frmWdt/2,	-_elevHgt,	15,
				_frmWdt/2,	-_elevHgt,	15,
				_frmWdt/2,	0,			15
		endif
	endif

	prism_	nsp/3,	_elevThk,	get(nsp)

return

!-----------------------------------------------------------------------------------------------
"elev_hFrame":
!-----------------------------------------------------------------------------------------------
	pen			frmElevPen
	material	frmMat

	if	(_frmType = FRAME_BOUNDARY & _frmClass = HFRAME_CORNER)	then
		put	_xPosFrmL_Elev,	0,										15,
			_xPosFrmL_Elev,	-((_frmWdt + _gskWdt)/2)/cos(aTilt),	15,
			_xPosFrmR_Elev,	-((_frmWdt + _gskWdt)/2)/cos(aTilt),	15,
			_xPosFrmR_Elev,	0,										15
	endif
	if	(_frmType = FRAME_TRANSOM & _frmClass = HFRAME_CORNER) | _frmClass = HFRAME_TRANSOM	then
		if	iTrsType = TRS_TYPE1	then
			put	_xPosFrmL_Elev,	-((_frmWdt - _gskWdt)/2)/cos(aTilt),	15,
				_xPosFrmL_Elev,	-((_frmWdt + _gskWdt)/2)/cos(aTilt),	15,
				_xPosFrmR_Elev,	-((_frmWdt + _gskWdt)/2)/cos(aTilt),	15,
				_xPosFrmR_Elev,	-((_frmWdt - _gskWdt)/2)/cos(aTilt),	15
		endif
		if	iTrsType = TRS_TYPE2	then
			put	_xPosFrmL_Elev,	0,						15,
				_xPosFrmL_Elev,	-_frmWdt/cos(aTilt),	15,
				_xPosFrmR_Elev,	-_frmWdt/cos(aTilt),	15,
				_xPosFrmR_Elev,	0,						15
		endif
	endif

	prism_	nsp/3,	_elevThk,	get(nsp)

return

!-----------------------------------------------------------------------------------------------
"elev_pnl_Matrix":
!-----------------------------------------------------------------------------------------------
	!	유리
	if	not(_pnlType = PNL_GRILL | _pnlType = PNL_OPEN)	then
		add	_xPosPnl,	-_offsetB_PNL,	0
			gosub	"elev_pnlWin"
		del 1
	endif

	!	텍스트
	if	_pnlType = PNL_FIX | _pnlType = PNL_SPANDREL | _pnlType = PNL_PROJECT_SMOKE	then
		if	_pnlType = PNL_FIX | _pnlType = PNL_SPANDREL	then
			_stFix = "F"
			_bCircle = 0
		else
			_stFix = "배"
			_bCircle = 1
		endif

		add	_xPosPnl + _pnlWdt/2,	-(_offsetB_PNL + _pnlHgt/2),	_elevThk
			gosub	"elev_pnlTxt"
		del 1
	endif

	!	열림표현
	if	_pnlType = PNL_PROJECT | _pnlType = PNL_PROJECT_SMOKE	then
		add	_xPosPnl,	-_offsetB_PNL,	0
			gosub	"elev_pnlOpen"
		del 1
	endif

	!	그릴
	if	_pnlType = PNL_GRILL | _pnlType = PNL_OPEN	then
		addx	_xPosEtc
			gosub	"elev_pnlGrl"
		del 1
	endif

return

!-----------------------------------------------------------------------------------------------
"elev_pnlWin":	!	창호입면도 : 패널 : 유리
!-----------------------------------------------------------------------------------------------
	pen			glsElevPen
	material	glsMat
	if	_pnlType = PNL_SPANDREL			then	material	spdGlsMat_1
	if	_pnlType = PNL_SPANDREL_SUB		then	material	spdGlsMat_2
	if	_pnlType = PNL_SPANDREL_SUB2	then	material	spdGlsMat_3
	if	_pnlType = PNL_SPANDREL_SUB3	then	material	spdGlsMat_4

	put	0,			0,			15,
		0,			-_pnlHgt,	15,
		_pnlWdt,	-_pnlHgt,	15,
		_pnlWdt,	0,			15

	prism_	nsp/3,	_elevThk,	get(nsp)

return

!-----------------------------------------------------------------------------------------------
"elev_pnlTxt":	!	창호입면도 : 패널 : 텍스트
!-----------------------------------------------------------------------------------------------
	pen			txtPen
	material	txtMat
	style		"txtSty_Fix"

	mulx	-1
		muly	-1
			text	_elevThk,	0,	_stFix
			if	_bCircle	then
				model	wire
					circle	txtSize/1000
				model	solid
			endif
		del 1
	del 1

return

!-----------------------------------------------------------------------------------------------
"elev_pnlOpen":	!	창호입면도 : 패널 : 열림표현
!-----------------------------------------------------------------------------------------------
	pen	oplinePen

	if	_hingeType = HINGE_TOP | _hingeType = HINGE_TOP_LEFT | _hingeType = HINGE_TOP_RIGHT	then
		lin_	0,			0,			0,
				_pnlWdt/2,	-_pnlHgt,	0

		lin_	_pnlWdt/2,	-_pnlHgt,	0,
				_pnlWdt,	0,			0
	endif

	if	_hingeType = HINGE_BOTTOM | _hingeType = HINGE_BOTTOM_LEFT | _hingeType = HINGE_BOTTOM_RIGHT	then
		lin_	0,			-_pnlHgt,	0,
				_pnlWdt/2,	0,			0

		lin_	_pnlWdt/2,	0,			0,
				_pnlWdt,	-_pnlHgt,	0
	endif

	if	_hingeType = HINGE_LEFT | _hingeType = HINGE_TOP_LEFT | _hingeType = HINGE_BOTTOM_LEFT	then
		lin_	_pnlWdt,	0,			0,
				0,			-_pnlHgt/2,	0

		lin_	0,			-_pnlHgt/2,	0,
				_pnlWdt,	-_pnlHgt,	0
	endif

	if	_hingeType = HINGE_RIGHT | _hingeType = HINGE_TOP_RIGHT | _hingeType = HINGE_BOTTOM_RIGHT	then
		lin_	0,			0,			0,
				_pnlWdt,	-_pnlHgt/2,	0

		lin_	_pnlWdt,	-_pnlHgt/2,	0,
				0,			-_pnlHgt,	0
	endif

return

!-----------------------------------------------------------------------------------------------
"elev_pnlGrl":	!	창호입면도 : 패널 : 그릴
!-----------------------------------------------------------------------------------------------
	!	프레임 뒷부분
	pen	frmElevPen

	addy	-_offsetB_PNL
		lin_	0,	0,			0,
				0,	-_pnlHgt,	0

		lin_	_etcWdt,	0,			0,
				_etcWdt,	-_pnlHgt,	0
	del 1

	addy	-_offsetB_ETC
		lin_	0,			0,	0,
				_etcWdt,	0,	0

		addy	-_etcHgt
			lin_	0,			0,	0,
					_etcWdt,	0,	0
		del 1
	del 1

	if	_pnlType = PNL_GRILL	then
		!	그릴
		pen	grlElevPen

		_nGrl = int(_etcHgt/grlGap)
		_rGrl = (_etcHgt MOD grlGap)/2

		addy	-(_offsetB_ETC + _rGrl)
			for	m = 1	to	_nGrl
				addy	-grlGap/2
					lin_	0,			0,	0,
							_etcWdt,	0,	0
				del 1

				addy	-grlGap
			next	m

			del _nGrl
		del 1
	endif

return
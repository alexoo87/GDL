!===============================================================================================
!	코너 경사커튼월
!===============================================================================================
!	W.P
hotspot	0,	0,	0

!	벡터 방향
_dxL = matrixPoint[2][1] - matrixPoint[1][1]
_dyL = matrixPoint[2][2] - matrixPoint[1][2]
_dzL = matrixPoint[2][3] - matrixPoint[1][3]

_dxR = matrixPoint[3][1] - matrixPoint[4][1]
_dyR = matrixPoint[3][2] - matrixPoint[4][2]
_dzR = matrixPoint[3][3] - matrixPoint[4][3]

if	bGuide	then
	lin_	0,	0,	0,	_dxL,	_dyL,	_dzL
	hotline	0,	0,	0,	_dxL,	_dyL,	_dzL,	unID	:	unID = unID + 1

	addx	ctwWdt
		lin_	0,	0,	0,	_dxR,	_dyR,	_dzR
		hotline	0,	0,	0,	_dxR,	_dyR,	_dzR,	unID	:	unID = unID + 1
	del 1
endif

!	Mullion Type
_iMlnTypeL = iMlnType
if	not(bFrmCapL)	then	_iMlnTypeL = MLN_TYPE1

_iMlnTypeR = iMlnType
if	not(bFrmCapR)	then	_iMlnTypeR = MLN_TYPE1

!	_bMlnTypeL1/_bMlnTypeL2
_bMlnTypeL1 = (iFrmTypeL = FrmType_Boundary) | (iFrmTypeL = FrmType_Mullion & _iMlnTypeL = Mln_Type1)
_bMlnTypeL2 = (iFrmTypeL = FrmType_Mullion & _iMlnTypeL = Mln_Type2)

!	_bMlnTypeR1/_bMlnTypeR2
_bMlnTypeR1 = (iFrmTypeR = FrmType_Boundary) | (iFrmTypeR = FrmType_Mullion & _iMlnTypeR = Mln_Type1)
_bMlnTypeR2 = (iFrmTypeR = FrmType_Mullion & _iMlnTypeR = Mln_Type2)


!===============================================================================================
!	Hotspot
!===============================================================================================
!	변수 정의
_yPosL = matrixPoint[2][2]
_yPosR = matrixPoint[3][2]

!	ctwHgt
addx	matrixPoint[4][1]/2
	hotspot	0,	0,	0,		unID,	ctwHgt,	1+128	:	unID = unID + 1
	hotspot	0,	0,	-1,		unID,	ctwHgt,	3		:	unID = unID + 1
	hotspot	0,	0,	ctwHgt,	unID,	ctwHgt,	2		:	unID = unID + 1
del 1

!	trsGap
if	not(nTrs < eps) & not(bEqualGap)	then
	dim	_stTrsGap[]

	addx	matrixPoint[4][1]/2
		for	i = 1	to	nTrs
			_stTrsGap[i] = str(i,	1,	0) + "번째 트랜섬"

			hotspot	0,	0,	0,			unID,	trsGap[i],	1+128,	trsGap[i],	_stTrsGap[i]	:	unID = unID + 1
			hotspot	0,	0,	-1,			unID,	trsGap[i],	3,		trsGap[i],	_stTrsGap[i]	:	unID = unID + 1
			hotspot	0,	0,	trsGap[i],	unID,	trsGap[i],	2,		trsGap[i],	_stTrsGap[i]	:	unID = unID + 1
		next	i
	del 1
endif

!	Point2
addz	ctwHgt
	addy	_yPosL
		hotspot	0,					0,	0,	unID,	matrixPoint[2][1],	1	:	unID = unID + 1
		hotspot	-1,					0,	0,	unID,	matrixPoint[2][1],	3	:	unID = unID + 1
		hotspot	matrixPoint[2][1],	0,	0,	unID,	matrixPoint[2][1],	2	:	unID = unID + 1
	del 1
del 1

!	Point3
addz	ctwHgt
	addy	_yPosR
		hotspot	0,					0,	0,	unID,	matrixPoint[3][1],	1	:	unID = unID + 1
		hotspot	-1,					0,	0,	unID,	matrixPoint[3][1],	3	:	unID = unID + 1
		hotspot	matrixPoint[3][1],	0,	0,	unID,	matrixPoint[3][1],	2	:	unID = unID + 1
	del 1
del 1

!	Point4
hotspot	0,		0,	0,	unID,	ctwWdt,	1	:	unID = unID + 1
hotspot	-1,		0,	0,	unID,	ctwWdt,	3	:	unID = unID + 1
hotspot	ctwWdt,	0,	0,	unID,	ctwWdt,	2	:	unID = unID + 1

!	aTiltL/aTiltR
_tiltLth = ctwHgt + 0.100

hotspot	0,	0,						_tiltLth,				unID,	aTiltL,	4	: unID = unID + 1
hotspot	0,	-_tiltLth*sin(aTiltL),	_tiltLth*cos(aTiltL),	unID,	aTiltL,	5	: unID = unID + 1
hotspot	0,	0,						0,						unID,	aTiltL,	6	: unID = unID + 1
hotspot	1,	0,						0,						unID,	aTiltL,	7	: unID = unID + 1

if	bGuide	then
	lin_	0,	0,	0,	0,	-_tiltLth*sin(aTiltL),	_tiltLth*cos(aTiltL)
	hotline	0,	0,	0,	0,	-_tiltLth*sin(aTiltL),	_tiltLth*cos(aTiltL),	unID	:	unID = unID + 1
endif

addx	ctwWdt
	hotspot	0,	0,						_tiltLth,				unID,	aTiltR,	4	: unID = unID + 1
	hotspot	0,	-_tiltLth*sin(aTiltR),	_tiltLth*cos(aTiltR),	unID,	aTiltR,	5	: unID = unID + 1
	hotspot	0,	0,						0,						unID,	aTiltR,	6	: unID = unID + 1
	hotspot	1,	0,						0,						unID,	aTiltR,	7	: unID = unID + 1

	if	bGuide	then
		lin_	0,	0,	0,	0,	-_tiltLth*sin(aTiltR),	_tiltLth*cos(aTiltR)
		hotline	0,	0,	0,	0,	-_tiltLth*sin(aTiltR),	_tiltLth*cos(aTiltR),	unID	:	unID = unID + 1
	endif
del 1


!===============================================================================================
!	2D Display Options
!===============================================================================================
!gs_2D_projection_type:
!	0 - Normal 3D
!	1 - View Edges
!	2 - View Polygons
!	3 - Overhead Edges
!	4 - Cut Lines
!	5 - Cut Polygons
!	6 - Bottom Range Cut Lines
!	7 - Top Range Cut Lines

if	GLOB_VIEW_TYPE = 2	then
	if	gs_2D_projection	then
		if	gs_symb_show_projection_to = stProjectionTypes[1] | (gs_symb_show_projection_to = stProjectionTypes[2] & gs_bottom_range_height < gs_cutplane_height)	then
			addz gs_bottom_range_height
				cutplane{2} 180, 2
			del 1
		endif

		if	gs_2D_projection_type <> 6	then
			addz gs_cutplane_height
				cutplane{2} 180 * (gs_2D_projection_type = 3), 1
			del 1
		endif

		if	gs_symb_show_projection_to <> stProjectionTypes[3]	then
			addz gs_top_range_height
				cutplane{2} 0, 2
			del 1
		endif
	endif
endif
!===============================================================================================


!===============================================================================================
!	좌/우 프레임
!===============================================================================================
pen			frmPen_Elev
sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmPen_Sect
material	frmMat

!	변수 정의
!-----------------------------------------------------------------------------------------------
_frmPos = 0
_frmHgt = ctwHgt

_bCutFrmB = 0
_zPosCutFrmB = 0
if	not(bFrmB)	then
	_bCutFrmB = 1
	_zPosCutFrmB = frmWdtB
endif

_bCutFrmT = 0
_zPosCutFrmT = ctwHgt
if	not(bFrmT)	then
	_bCutFrmT = 1
	_zPosCutFrmT = ctwHgt - frmWdtT
endif

!	비율
_ratio_frmB = _zPosCutFrmB/ctwHgt
_ratio_frmT = _zPosCutFrmT/ctwHgt

	!	좌측 프레임 하부/상부 핫스팟 좌표 이동 값
	_xTransL_frmB = _dxL*_ratio_frmB
	_yTransL_frmB = _dyL*_ratio_frmB

	_xTransL_frmT = _dxL*_ratio_frmT
	_yTransL_frmT = _dyL*_ratio_frmT

	!	우측 프레임 하부/상부 핫스팟  좌표 이동 값
	_xTransR_frmB = _dxR*_ratio_frmB
	_yTransR_frmB = _dyR*_ratio_frmB

	_xTransR_frmT = _dxR*_ratio_frmT
	_yTransR_frmT = _dyR*_ratio_frmT

!	좌측 프레임
!-----------------------------------------------------------------------------------------------
dim	_xPosTransL[],	_yPosTransL[]

if	iFrmTypeL = FrmType_Boundary	then
	_xPosTransL[1] = (frmWdtL + gskWdtL)/2
	_xPosTransL[2] = (frmWdtL + gskWdtL)/2
	_xPosTransL[3] = frmWdtL
	_xPosTransL[4] = frmWdtL
	_xPosTransL[5] = 0
	_xPosTransL[6] = 0

	_yPosTransL[1] = 0
	_yPosTransL[2] = gskThk
	_yPosTransL[3] = gskThk
	_yPosTransL[4] = frmThkL + gskThk
	_yPosTransL[5] = frmThkL + gskThk
	_yPosTransL[6] = 0

	_nFrmL = 6
endif

if	iFrmTypeL = FrmType_Mullion	then
	!	Angle
	_aFrmL = -aFrmL
	_aSubL = 90 - _aFrmL

	!	Position
	_referLth = (gskWdtL/2)*tan(_aFrmL)
	_xPosL_refer = _referLth*cos(_aSubL)
	_yPosL_refer = _referLth*sin(_aSubL)

	!	Mullion Type
	_iMlnType = iMlnType
	if	not(bFrmCapL)	then	_iMlnType = MLN_TYPE1

	!	Point
	dim	_frmPointL[][]

		if	iCornerType = CORNER_TYPE1	then
			if	_iMlnType = Mln_Type1	then
				!	Point1
				_frmPointL[1][1] = gskWdtL/2
				_frmPointL[1][2] = 0

				!	Point2
				_frmPointL[2][1] = gskWdtL/2
				_frmPointL[2][2] = gskThk/cos(_aFrmL) + (frmWdtL - gskWdtL)/2*tan(_aFrmL)

				!	Point3
				_frmPointL[3][1] = frmWdtL/2
				_frmPointL[3][2] = _frmPointL[2][2]

				!	Point4
				_frmPointL[4][1] = frmWdtL/2
				_frmPointL[4][2] = _frmPointL[2][2] + frmThkL/cos(_aFrmL)

				!	Point5
				_frmPointL[5][1] = -frmWdtL/2
				_frmPointL[5][2] = _frmPointL[4][2]

				!	Point6
				_frmPointL[6][1] = -frmWdtL/2
				_frmPointL[6][2] = _frmPointL[2][2]

				!	Point7
				_frmPointL[7][1] = -gskWdtL/2
				_frmPointL[7][2] = _frmPointL[2][2]

				!	Point8
				_frmPointL[8][1] = -gskWdtL/2
				_frmPointL[8][2] = 0

				_nFrmL = 8
			endif

			if	_iMlnType = Mln_Type2	then
				!	Point1
				_frmPointL[1][1] = gskWdtL/2
				_frmPointL[1][2] = 0

				!	Point2
				_frmPointL[2][1] = frmWdtL/2
				_frmPointL[2][2] = ((frmWdtL - gskWdtL)/2)*tan(_aFrmL)

				!	Point3
				_frmPointL[3][1] = frmWdtL/2
				_frmPointL[3][2] = _frmPointL[2][2] + gskCapThk/cos(_aFrmL)

				!	Point4
				_frmPointL[4][1] = gskWdtL/2
				_frmPointL[4][2] = gskCapThk/cos(_aFrmL)

				!	Point5
				_frmPointL[5][1] = gskWdtL/2
				_frmPointL[5][2] = gskThk/cos(_aFrmL) + (frmWdtL - gskWdtL)/2*tan(_aFrmL)

				!	Point6
				_frmPointL[6][1] = frmWdtL/2
				_frmPointL[6][2] = _frmPointL[5][2]

				!	Point7
				_frmPointL[7][1] = frmWdtL/2
				_frmPointL[7][2] = _frmPointL[5][2] + frmThkL/cos(_aFrmL)

				!	Point8
				_frmPointL[8][1] = -frmWdtL/2
				_frmPointL[8][2] = _frmPointL[7][2]

				!	Point9
				_frmPointL[9][1] = -frmWdtL/2
				_frmPointL[9][2] = _frmPointL[5][2]

				!	Point10
				_frmPointL[10][1] = -gskWdtL/2
				_frmPointL[10][2] = _frmPointL[5][2]

				!	Point11
				_frmPointL[11][1] = -gskWdtL/2
				_frmPointL[11][2] = gskCapThk/cos(_aFrmL)

				!	Point12
				_frmPointL[12][1] = -frmWdtL/2
				_frmPointL[12][2] = _frmPointL[2][2] + gskCapThk/cos(_aFrmL)

				!	Point13
				_frmPointL[13][1] = -frmWdtL/2
				_frmPointL[13][2] = _frmPointL[2][2]

				!	Point14
				_frmPointL[14][1] = -gskWdtL/2
				_frmPointL[14][2] = 0

				_nFrmL = 14
			endif
		endif

		if	iCornerType = CORNER_TYPE2	then
			if	_iMlnType = Mln_Type1	then
				!	Point1
				_frmPointL[1][1] = gskWdtL/2
				_frmPointL[1][2] = 0

				!	Point2
				_frmPointL[2][1] = gskWdtL/2
				_frmPointL[2][2] = gskThk/cos(_aFrmL)

				!	Point3
				_frmPointL[3][1] = frmWdtL/2
				_frmPointL[3][2] = gskThk/cos(_aFrmL) + (frmWdtL - gskWdtL)/2*tan(_aFrmL)

				!	Point4
				_frmPointL[4][1] = frmWdtL/2
				_frmPointL[4][2] = _frmPointL[3][2] + frmThkL/cos(_aFrmL)

				!	Point5
				_frmPointL[5][1] = 0
				_frmPointL[5][2] = _frmPointL[4][2] - (frmWdtL/2)*tan(_aFrmL)

				!	Point6
				_frmPointL[6][1] = -frmWdtL/2
				_frmPointL[6][2] = _frmPointL[4][2]

				!	Point7
				_frmPointL[7][1] = -frmWdtL/2
				_frmPointL[7][2] = _frmPointL[3][2]

				!	Point8
				_frmPointL[8][1] = -gskWdtL/2
				_frmPointL[8][2] = _frmPointL[2][2]

				!	Point9
				_frmPointL[9][1] = -gskWdtL/2
				_frmPointL[9][2] = 0

				_nFrmL = 9
			endif

			if	_iMlnType = Mln_Type2	then
				!	Point1
				_frmPointL[1][1] = gskWdtL/2
				_frmPointL[1][2] = 0

				!	Point2
				_frmPointL[2][1] = frmWdtL/2
				_frmPointL[2][2] = ((frmWdtL - gskWdtL)/2)*tan(_aFrmL)

				!	Point3
				_frmPointL[3][1] = frmWdtL/2
				_frmPointL[3][2] = _frmPointL[2][2] + gskCapThk/cos(_aFrmL)

				!	Point4
				_frmPointL[4][1] = gskWdtL/2
				_frmPointL[4][2] = gskCapThk/cos(_aFrmL)

				!	Point5
				_frmPointL[5][1] = gskWdtL/2
				_frmPointL[5][2] = gskThk/cos(_aFrmL)

				!	Point6
				_frmPointL[6][1] = frmWdtL/2
				_frmPointL[6][2] = gskThk/cos(_aFrmL) + (frmWdtL - gskWdtL)/2*tan(_aFrmL)

				!	Point7
				_frmPointL[7][1] = frmWdtL/2
				_frmPointL[7][2] = _frmPointL[6][2] + frmThkL/cos(_aFrmL)

				!	Point8
				_frmPointL[8][1] = 0
				_frmPointL[8][2] = _frmPointL[7][2] - (frmWdtL/2)*tan(_aFrmL)

				!	Point9
				_frmPointL[9][1] = -frmWdtL/2
				_frmPointL[9][2] = _frmPointL[7][2]

				!	Point10
				_frmPointL[10][1] = -frmWdtL/2
				_frmPointL[10][2] = _frmPointL[6][2]

				!	Point11
				_frmPointL[11][1] = -gskWdtL/2
				_frmPointL[11][2] = _frmPointL[5][2]

				!	Point12
				_frmPointL[12][1] = -gskWdtL/2
				_frmPointL[12][2] = gskCapThk/cos(_aFrmL)

				!	Point13
				_frmPointL[13][1] = -frmWdtL/2
				_frmPointL[13][2] = _frmPointL[2][2] + gskCapThk/cos(_aFrmL)

				!	Point14
				_frmPointL[14][1] = -frmWdtL/2
				_frmPointL[14][2] = _frmPointL[2][2]

				!	Point15
				_frmPointL[15][1] = -gskWdtL/2
				_frmPointL[15][2] = 0

				_nFrmL = 15
			endif
		endif

	!	Put	Values
	for	i = 1	to	_nFrmL
		!	좌표 회전 / 좌표 이동
		_xPosTransL[i] = (_frmPointL[i][1])*cos(aFrmL) - (_frmPointL[i][2])*sin(aFrmL) + _xPosL_refer
		_yPosTransL[i] = (_frmPointL[i][1])*sin(aFrmL) + (_frmPointL[i][2])*cos(aFrmL) + _yPosL_refer
	next	i
endif

!	프레임 그리기
if	bFrmL	then
	!	하부 좌표
	for	i = 1	to	_nFrmL
		put	_xPosTransL[i],	_yPosTransL[i],	0
	next	i

	!	상부 좌표
	for	i = 1	to	_nFrmL
		put	_xPosTransL[i] + _dxL,	_yPosTransL[i] + _dyL,	_frmHgt
	next	i

	!	하부/상부 Cut
	_nCutFrm = 0
	if	_bCutFrmB	then
		addz	_zPosCutFrmB
			cutplane	1,	1,	0,	1	:	_nCutFrm = _nCutFrm + 1
		del 1
	endif
	if	_bCutFrmT	then
		addz	_zPosCutFrmT
			cutplane	1,	1,	0,	0	:	_nCutFrm = _nCutFrm + 1
		del 1
	endif
	
		ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp) 
	
	if	_nCutFrm > eps	then
		for	c = 1	to	_nCutFrm
			cutend
		next	c
	endif
endif

!	Hotspot
for	i = 1	to	_nFrmL
	hotspot	_xPosTransL[i] + _xTransL_frmB,	_yPosTransL[i] + _yTransL_frmB,	_zPosCutFrmB

	hotspot	_xPosTransL[i] + _xTransL_frmT,	_yPosTransL[i] + _yTransL_frmT,	_zPosCutFrmT
next	i


!	우측 프레임
!-----------------------------------------------------------------------------------------------
dim	_xPosTransR[],	_yPosTransR[]

addx	ctwWdt
	if	iFrmTypeR = FrmType_Boundary	then
		_xPosTransR[1] = -(frmWdtR + gskWdtR)/2
		_xPosTransR[2] = -(frmWdtR + gskWdtR)/2
		_xPosTransR[3] = -frmWdtR
		_xPosTransR[4] = -frmWdtR
		_xPosTransR[5] = 0
		_xPosTransR[6] = 0

		_yPosTransR[1] = 0
		_yPosTransR[2] = gskThk
		_yPosTransR[3] = gskThk
		_yPosTransR[4] = frmThkR + gskThk
		_yPosTransR[5] = frmThkR + gskThk
		_yPosTransR[6] = 0

		_nFrmR = 6
	endif

	if	iFrmTypeR = FrmType_Mullion	then
		!	Angle
		_aFrmR = aFrmR
		_aSubR = 90 - _aFrmR

		!	Position
		_referLth = (gskWdtR/2)*tan(_aFrmR)
		_xPosR_refer = _referLth*cos(_aSubR)
		_yPosR_refer = _referLth*sin(_aSubR)

		!	Mullion Type
		_iMlnType = iMlnType
		if	not(bFrmCapR)	then	_iMlnType = MLN_TYPE1

		!	Point
		dim	_frmPointR[][]

			if	iCornerType = CORNER_TYPE1	then
				if	_iMlnType = Mln_Type1	then
					!	Point1
					_frmPointR[1][1] = -gskWdtR/2
					_frmPointR[1][2] = 0

					!	Point2
					_frmPointR[2][1] = -gskWdtR/2
					_frmPointR[2][2] = gskThk/cos(_aFrmR) + (frmWdtR - gskWdtR)/2*tan(_aFrmR)

					!	Point3
					_frmPointR[3][1] = -frmWdtR/2
					_frmPointR[3][2] = _frmPointR[2][2]

					!	Point4
					_frmPointR[4][1] = -frmWdtR/2
					_frmPointR[4][2] = _frmPointR[2][2] + frmThkR/cos(_aFrmR)

					!	Point5
					_frmPointR[5][1] = frmWdtR/2
					_frmPointR[5][2] = _frmPointR[4][2]

					!	Point6
					_frmPointR[6][1] = frmWdtR/2
					_frmPointR[6][2] = _frmPointR[2][2]

					!	Point7
					_frmPointR[7][1] = gskWdtR/2
					_frmPointR[7][2] = _frmPointR[2][2]

					!	Point8
					_frmPointR[8][1] = gskWdtR/2
					_frmPointR[8][2] = 0

					_nFrmR = 8
				endif

				if	_iMlnType = Mln_Type2	then
					!	Point1
					_frmPointR[1][1] = -gskWdtR/2
					_frmPointR[1][2] = 0

					!	Point2
					_frmPointR[2][1] = -frmWdtR/2
					_frmPointR[2][2] = ((frmWdtR - gskWdtR)/2)*tan(_aFrmR)

					!	Point3
					_frmPointR[3][1] = -frmWdtR/2
					_frmPointR[3][2] = _frmPointR[2][2] + gskCapThk/cos(_aFrmR)

					!	Point4
					_frmPointR[4][1] = -gskWdtR/2
					_frmPointR[4][2] = gskCapThk/cos(_aFrmR)

					!	Point5
					_frmPointR[5][1] = -gskWdtR/2
					_frmPointR[5][2] = gskThk/cos(_aFrmR) + (frmWdtR - gskWdtR)/2*tan(_aFrmR)

					!	Point6
					_frmPointR[6][1] = -frmWdtR/2
					_frmPointR[6][2] = _frmPointR[5][2]

					!	Point7
					_frmPointR[7][1] = -frmWdtR/2
					_frmPointR[7][2] = _frmPointR[5][2] + frmThkR/cos(_aFrmR)

					!	Point8
					_frmPointR[8][1] = frmWdtR/2
					_frmPointR[8][2] = _frmPointR[7][2]

					!	Point9
					_frmPointR[9][1] = frmWdtR/2
					_frmPointR[9][2] = _frmPointR[5][2]

					!	Point10
					_frmPointR[10][1] = gskWdtR/2
					_frmPointR[10][2] = _frmPointR[5][2]

					!	Point11
					_frmPointR[11][1] = gskWdtR/2
					_frmPointR[11][2] = gskCapThk/cos(_aFrmR)

					!	Point12
					_frmPointR[12][1] = frmWdtR/2
					_frmPointR[12][2] = _frmPointR[2][2] + gskCapThk/cos(_aFrmR)

					!	Point13
					_frmPointR[13][1] = frmWdtR/2
					_frmPointR[13][2] = _frmPointR[2][2]

					!	Point14
					_frmPointR[14][1] = gskWdtR/2
					_frmPointR[14][2] = 0

					_nFrmR = 14
				endif
			endif

			if	iCornerType = CORNER_TYPE2	then
				if	_iMlnType = Mln_Type1	then
					!	Point1
					_frmPointR[1][1] = -gskWdtR/2
					_frmPointR[1][2] = 0

					!	Point2
					_frmPointR[2][1] = -gskWdtR/2
					_frmPointR[2][2] = gskThk/cos(_aFrmR)

					!	Point3
					_frmPointR[3][1] = -frmWdtR/2
					_frmPointR[3][2] = gskThk/cos(_aFrmR) + (frmWdtR - gskWdtR)/2*tan(_aFrmR)

					!	Point4
					_frmPointR[4][1] = -frmWdtR/2
					_frmPointR[4][2] = _frmPointR[3][2] + frmThkR/cos(_aFrmR)

					!	Point5
					_frmPointR[5][1] = 0
					_frmPointR[5][2] = _frmPointR[4][2] - (frmWdtR/2)*tan(_aFrmR)

					!	Point6
					_frmPointR[6][1] = frmWdtR/2
					_frmPointR[6][2] = _frmPointR[4][2]

					!	Point7
					_frmPointR[7][1] = frmWdtR/2
					_frmPointR[7][2] = _frmPointR[3][2]

					!	Point8
					_frmPointR[8][1] = gskWdtR/2
					_frmPointR[8][2] = _frmPointR[2][2]

					!	Point9
					_frmPointR[9][1] = gskWdtR/2
					_frmPointR[9][2] = 0

					_nFrmR = 9
				endif

				if	_iMlnType = Mln_Type2	then
					!	Point1
					_frmPointR[1][1] = -gskWdtR/2
					_frmPointR[1][2] = 0

					!	Point2
					_frmPointR[2][1] = -frmWdtR/2
					_frmPointR[2][2] = ((frmWdtR - gskWdtR)/2)*tan(_aFrmR)

					!	Point3
					_frmPointR[3][1] = -frmWdtR/2
					_frmPointR[3][2] = _frmPointR[2][2] + gskCapThk/cos(_aFrmR)

					!	Point4
					_frmPointR[4][1] = -gskWdtR/2
					_frmPointR[4][2] = gskCapThk/cos(_aFrmR)

					!	Point5
					_frmPointR[5][1] = -gskWdtR/2
					_frmPointR[5][2] = gskThk/cos(_aFrmR)

					!	Point6
					_frmPointR[6][1] = -frmWdtR/2
					_frmPointR[6][2] = gskThk/cos(_aFrmR) + (frmWdtR - gskWdtR)/2*tan(_aFrmR)

					!	Point7
					_frmPointR[7][1] = -frmWdtR/2
					_frmPointR[7][2] = _frmPointR[6][2] + frmThkR/cos(_aFrmR)

					!	Point8
					_frmPointR[8][1] = 0
					_frmPointR[8][2] = _frmPointR[7][2] - (frmWdtR/2)*tan(_aFrmR)

					!	Point9
					_frmPointR[9][1] = frmWdtR/2
					_frmPointR[9][2] = _frmPointR[7][2]

					!	Point10
					_frmPointR[10][1] = frmWdtR/2
					_frmPointR[10][2] = _frmPointR[6][2]

					!	Point11
					_frmPointR[11][1] = gskWdtR/2
					_frmPointR[11][2] = _frmPointR[5][2]

					!	Point12
					_frmPointR[12][1] = gskWdtR/2
					_frmPointR[12][2] = gskCapThk/cos(_aFrmR)

					!	Point13
					_frmPointR[13][1] = frmWdtR/2
					_frmPointR[13][2] = _frmPointR[2][2] + gskCapThk/cos(_aFrmR)

					!	Point14
					_frmPointR[14][1] = frmWdtR/2
					_frmPointR[14][2] = _frmPointR[2][2]

					!	Point15
					_frmPointR[15][1] = gskWdtR/2
					_frmPointR[15][2] = 0

					_nFrmR = 15
				endif
			endif

		!	Put	Values
		for	i = 1	to	_nFrmR
			!	좌표 회전 / 좌표 이동
			_xPosTransR[i] = (_frmPointR[i][1])*cos(aFrmR) - (_frmPointR[i][2])*sin(aFrmR) - _xPosR_refer
			_yPosTransR[i] = (_frmPointR[i][1])*sin(aFrmR) + (_frmPointR[i][2])*cos(aFrmR) + _yPosR_refer
		next	i
	endif

	!	프레임 그리기
	if	bFrmR	then
		!	하부 좌표
		for	i = 1	to	_nFrmR
			put	_xPosTransR[i],	_yPosTransR[i],	0
		next	i

		!	상부 좌표
		for	i = 1	to	_nFrmR
			put	_xPosTransR[i] + _dxR,	_yPosTransR[i] + _dyR,	_frmHgt
		next	i

		!	하부/상부 Cut
		_nCutFrm = 0
		if	_bCutFrmB	then
			addz	_zPosCutFrmB
				cutplane	1,	1,	0,	1	:	_nCutFrm = _nCutFrm + 1
			del 1
		endif
		if	_bCutFrmT	then
			addz	_zPosCutFrmT
				cutplane	1,	1,	0,	0	:	_nCutFrm = _nCutFrm + 1
			del 1
		endif

			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)

		if	_nCutFrm > eps	then
			for	c = 1	to	_nCutFrm
				cutend
			next	c
		endif
	endif

	!	Hotspot
	for	i = 1	to	_nFrmR
		hotspot	_xPosTransR[i] + _xTransR_frmB,	_yPosTransR[i] + _yTransR_frmB,	_zPosCutFrmB

		hotspot	_xPosTransR[i] + _xTransR_frmT,	_yPosTransR[i] + _yTransR_frmT,	_zPosCutFrmT
	next	i
del 1


!===============================================================================================
!	상/하 프레임
!===============================================================================================
pen			frmPen_Elev
sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmPen_Sect
material	frmMat

!	하부 프레임
!-----------------------------------------------------------------------------------------------
if	bFrmB	then
	!	비율
	_ratioB = frmWdtB/ctwHgt
	_ratioB_gsk = ((frmWdtB + gskWdtB)/2)/ctwHgt
	_ratioB_pos = ((frmWdtB - gskWdtB)/2)/ctwHgt

	!	공통 프레임
		!	멀리언 타입에 따른 index
		if	_bMlnTypeL1	then
			_idxFrmB_1 = 3
			_idxFrmB_2 = 4
		endif
		if	_bMlnTypeL2	then
			_idxFrmB_1 = 6
			_idxFrmB_2 = 7
		endif

		if	_bMlnTypeR1	then
			_idxFrmB_3 = 4
			_idxFrmB_4 = 3
		endif
		if	_bMlnTypeR2	then
			_idxFrmB_3 = 7
			_idxFrmB_4 = 6
		endif

		!	하부 좌표
		put	_xPosTransL[_idxFrmB_1],			_yPosTransL[_idxFrmB_1],	0,
			_xPosTransL[_idxFrmB_2],			_yPosTransL[_idxFrmB_2],	0,
			ctwWdt + _xPosTransR[_idxFrmB_3],	_yPosTransR[_idxFrmB_3],	0,
			ctwWdt + _xPosTransR[_idxFrmB_4],	_yPosTransR[_idxFrmB_4],	0

		!	상부 좌표
		_xTransL_B = _dxL*_ratioB
		_yTransL_B = _dyL*_ratioB

		_xTransR_B = _dxR*_ratioB
		_yTransR_B = _dyR*_ratioB

		put	_xPosTransL[_idxFrmB_1] + _xTransL_B,			_yPosTransL[_idxFrmB_1] + _yTransL_B,	frmWdtB,
			_xPosTransL[_idxFrmB_2] + _xTransL_B,			_yPosTransL[_idxFrmB_2] + _yTransL_B,	frmWdtB,
			ctwWdt + _xPosTransR[_idxFrmB_3] + _xTransR_B,	_yPosTransR[_idxFrmB_3] + _yTransR_B,	frmWdtB,
			ctwWdt + _xPosTransR[_idxFrmB_4] + _xTransR_B,	_yPosTransR[_idxFrmB_4] + _yTransR_B,	frmWdtB

		ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)

	!	개스킷 : Boundary
	if	iFrmTypeB = FrmType_Boundary	then
		!	하부 좌표
		if	_bMlnTypeL1	then
			put	_xPosTransL[1],	_yPosTransL[1],	0,
				_xPosTransL[2],	_yPosTransL[2],	0,
				_xPosTransL[3],	_yPosTransL[3],	0
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2],	_yPosTransL[2],	0,
				_xPosTransL[3],	_yPosTransL[3],	0,
				_xPosTransL[4],	_yPosTransL[4],	0,
				_xPosTransL[5],	_yPosTransL[5],	0,
				_xPosTransL[6],	_yPosTransL[6],	0
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3],	_yPosTransR[3],	0,
				ctwWdt + _xPosTransR[2],	_yPosTransR[2],	0,
				ctwWdt + _xPosTransR[1],	_yPosTransR[1],	0
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6],	_yPosTransR[6],	0,
				ctwWdt + _xPosTransR[5],	_yPosTransR[5],	0,
				ctwWdt + _xPosTransR[4],	_yPosTransR[4],	0,
				ctwWdt + _xPosTransR[3],	_yPosTransR[3],	0,
				ctwWdt + _xPosTransR[2],	_yPosTransR[2],	0
		endif

		!	상부 좌표
		_xTransL_gskB = _dxL*_ratioB_gsk
		_yTransL_gskB = _dyL*_ratioB_gsk

		_xTransR_gskB = _dxR*_ratioB_gsk
		_yTransR_gskB = _dyR*_ratioB_gsk

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_gskB,	_yPosTransL[1] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[2] + _xTransL_gskB,	_yPosTransL[2] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_gskB,	_yPosTransL[2] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[4] + _xTransL_gskB,	_yPosTransL[4] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[5] + _xTransL_gskB,	_yPosTransL[5] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2,
				_xPosTransL[6] + _xTransL_gskB,	_yPosTransL[6] + _yTransL_gskB,	(frmWdtB + gskWdtB)/2
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[2] + _xTransR_gskB,	_yPosTransR[2] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[1] + _xTransR_gskB,	_yPosTransR[1] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_gskB,	_yPosTransR[6] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[5] + _xTransR_gskB,	_yPosTransR[5] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[4] + _xTransR_gskB,	_yPosTransR[4] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2,
				ctwWdt + _xPosTransR[2] + _xTransR_gskB,	_yPosTransR[2] + _yTransR_gskB,	(frmWdtB + gskWdtB)/2
		endif

		ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
	endif

	!	개스킷 : Transom Type1
	if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type1)	then
		!	하부 좌표
		_xTransL_posB = _dxL*_ratioB_pos
		_yTransL_posB = _dyL*_ratioB_pos

		_xTransR_posB = _dxR*_ratioB_pos
		_yTransR_posB = _dyR*_ratioB_pos

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_posB,	_yPosTransL[1] + _yTransL_posB,	0,
				_xPosTransL[2] + _xTransL_posB,	_yPosTransL[2] + _yTransL_posB,	0,
				_xPosTransL[3] + _xTransL_posB,	_yPosTransL[3] + _yTransL_posB,	0
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_posB,	_yPosTransL[2] + _yTransL_posB,	0,
				_xPosTransL[3] + _xTransL_posB,	_yPosTransL[3] + _yTransL_posB,	0,
				_xPosTransL[4] + _xTransL_posB,	_yPosTransL[4] + _yTransL_posB,	0,
				_xPosTransL[5] + _xTransL_posB,	_yPosTransL[5] + _yTransL_posB,	0,
				_xPosTransL[6] + _xTransL_posB,	_yPosTransL[6] + _yTransL_posB,	0
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_posB,	_yPosTransR[3] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posB,	_yPosTransR[2] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[1] + _xTransR_posB,	_yPosTransR[1] + _yTransR_posB,	0
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_posB,	_yPosTransR[6] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[5] + _xTransR_posB,	_yPosTransR[5] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[4] + _xTransR_posB,	_yPosTransR[4] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[3] + _xTransR_posB,	_yPosTransR[3] + _yTransR_posB,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posB,	_yPosTransR[2] + _yTransR_posB,	0
		endif

		!	상부 좌표
		_xTransL_gskB = _dxL*_ratioB_gsk
		_yTransL_gskB = _dyL*_ratioB_gsk

		_xTransR_gskB = _dxR*_ratioB_gsk
		_yTransR_gskB = _dyR*_ratioB_gsk

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_gskB,	_yPosTransL[1] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[2] + _xTransL_gskB,	_yPosTransL[2] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,	gskWdtB
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_gskB,	_yPosTransL[2] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[4] + _xTransL_gskB,	_yPosTransL[4] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[5] + _xTransL_gskB,	_yPosTransL[5] + _yTransL_gskB,	gskWdtB,
				_xPosTransL[6] + _xTransL_gskB,	_yPosTransL[6] + _yTransL_gskB,	gskWdtB
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[2] + _xTransR_gskB,	_yPosTransR[2] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[1] + _xTransR_gskB,	_yPosTransR[1] + _yTransR_gskB,	gskWdtB
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_gskB,	_yPosTransR[6] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[5] + _xTransR_gskB,	_yPosTransR[5] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[4] + _xTransR_gskB,	_yPosTransR[4] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,	gskWdtB,
				ctwWdt + _xPosTransR[2] + _xTransR_gskB,	_yPosTransR[2] + _yTransR_gskB,	gskWdtB
		endif

		addz	(frmWdtB - gskWdtB)/2
			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
		del 1
	endif

	!	개스킷 : Transom Type2
	if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type2)	then
		!	개스킷
			!	하부 좌표
			_xTransL_posB = _dxL*_ratioB_pos
			_yTransL_posB = _dyL*_ratioB_pos

			_xTransR_posB = _dxR*_ratioB_pos
			_yTransR_posB = _dyR*_ratioB_pos

			if	_bMlnTypeL1	then
				put	gskWdtL/2 + _xTransL_posB,		gskCapThk/cos(_aFrmL) + _yTransL_posB,	0,
					_xPosTransL[2] + _xTransL_posB,	_yPosTransL[2] + _yTransL_posB,			0,
					_xPosTransL[3] + _xTransL_posB,	_yPosTransL[3] + _yTransL_posB,			0
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[3] + _xTransL_posB,	_yPosTransL[3] + _yTransL_posB,	0,
					_xPosTransL[4] + _xTransL_posB,	_yPosTransL[4] + _yTransL_posB,	0,
					_xPosTransL[5] + _xTransL_posB,	_yPosTransL[5] + _yTransL_posB,	0,
					_xPosTransL[6] + _xTransL_posB,	_yPosTransL[6] + _yTransL_posB,	0
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_posB,	_yPosTransR[3] + _yTransR_posB,			0,
					ctwWdt + _xPosTransR[2] + _xTransR_posB,	_yPosTransR[2] + _yTransR_posB,			0,
					ctwWdt - gskWdtR/2 + _xTransR_posB,			gskCapThk/cos(_aFrmR) + _yTransR_posB,	0
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_posB,	_yPosTransR[6] + _yTransR_posB,	0,
					ctwWdt + _xPosTransR[5] + _xTransR_posB,	_yPosTransR[5] + _yTransR_posB,	0,
					ctwWdt + _xPosTransR[4] + _xTransR_posB,	_yPosTransR[4] + _yTransR_posB,	0,
					ctwWdt + _xPosTransR[3] + _xTransR_posB,	_yPosTransR[3] + _yTransR_posB,	0
			endif

			!	상부 좌표
			_xTransL_gskB = _dxL*_ratioB_gsk
			_yTransL_gskB = _dyL*_ratioB_gsk

			_xTransR_gskB = _dxR*_ratioB_gsk
			_yTransR_gskB = _dyR*_ratioB_gsk

			if	_bMlnTypeL1	then
				put	gskWdtL/2 + _xTransL_gskB,		gskCapThk/cos(_aFrmL) + _yTransL_gskB,	gskWdtB,
					_xPosTransL[2] + _xTransL_gskB,	_yPosTransL[2] + _yTransL_gskB,			gskWdtB,
					_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,			gskWdtB
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[3] + _xTransL_gskB,	_yPosTransL[3] + _yTransL_gskB,	gskWdtB,
					_xPosTransL[4] + _xTransL_gskB,	_yPosTransL[4] + _yTransL_gskB,	gskWdtB,
					_xPosTransL[5] + _xTransL_gskB,	_yPosTransL[5] + _yTransL_gskB,	gskWdtB,
					_xPosTransL[6] + _xTransL_gskB,	_yPosTransL[6] + _yTransL_gskB,	gskWdtB
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,			gskWdtB,
					ctwWdt + _xPosTransR[2] + _xTransR_gskB,	_yPosTransR[2] + _yTransR_gskB,			gskWdtB,
					ctwWdt - gskWdtR/2 + _xTransR_gskB,			gskCapThk/cos(_aFrmR) + _yTransR_gskB,	gskWdtB
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_gskB,	_yPosTransR[6] + _yTransR_gskB,	gskWdtB,
					ctwWdt + _xPosTransR[5] + _xTransR_gskB,	_yPosTransR[5] + _yTransR_gskB,	gskWdtB,
					ctwWdt + _xPosTransR[4] + _xTransR_gskB,	_yPosTransR[4] + _yTransR_gskB,	gskWdtB,
					ctwWdt + _xPosTransR[3] + _xTransR_gskB,	_yPosTransR[3] + _yTransR_gskB,	gskWdtB
			endif

			addz	(frmWdtB - gskWdtB)/2
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1

		!	개스킷 캡
			!	하부 좌표
			if	_bMlnTypeL1	then
				put	_xPosTransL[1],	_yPosTransL[1],			0,
					gskWdtL/2,		gskCapThk/cos(_aFrmL),	0
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2],	_yPosTransL[2],	0,
					_xPosTransL[3],	_yPosTransL[3],	0
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt - gskWdtR/2,			gskCapThk/cos(_aFrmR),	0,
					ctwWdt + _xPosTransR[1],	_yPosTransR[1],			0
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[3],	_yPosTransR[3],	0,
					ctwWdt + _xPosTransR[2],	_yPosTransR[2],	0
			endif

			!	상부 좌표
			_xTransL_capT = _dxL*_ratioB
			_yTransL_capT = _dyL*_ratioB

			_xTransR_capT = _dxR*_ratioB
			_yTransR_capT = _dyR*_ratioB

			if	_bMlnTypeL1	then
				put	_xPosTransL[1] + _xTransL_capT,	_yPosTransL[1] + _yTransL_capT,			frmWdtB,
					gskWdtL/2 + _xTransL_capT,		gskCapThk/cos(_aFrmL) + _yTransL_capT,	frmWdtB
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2] + _xTransL_capT,	_yPosTransL[2] + _yTransL_capT,	frmWdtB,
					_xPosTransL[3] + _xTransL_capT,	_yPosTransL[3] + _yTransL_capT,	frmWdtB
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt - gskWdtR/2 + _xTransR_capT,			gskCapThk/cos(_aFrmR) + _yTransR_capT,	frmWdtB,
					ctwWdt + _xPosTransR[1] + _xTransR_capT,	_yPosTransR[1] + _yTransR_capT,			frmWdtB
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_capT,	_yPosTransR[3] + _yTransR_capT,	frmWdtB,
					ctwWdt + _xPosTransR[2] + _xTransR_capT,	_yPosTransR[2] + _yTransR_capT,	frmWdtB
			endif

			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
	endif
endif


!	상부 프레임
!-----------------------------------------------------------------------------------------------
if	bFrmT	then
	!	비율
	_ratioT = (ctwHgt - frmWdtT)/ctwHgt
	_ratioT_gsk = (ctwHgt - (frmWdtT - gskWdtT)/2)/ctwHgt
	_ratioT_pos = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt

	!	공통 프레임
		!	멀리언 타입에 따른 index
		if	_bMlnTypeL1	then
			_idxFrmT_1 = 3
			_idxFrmT_2 = 4
		endif
		if	_bMlnTypeL2	then
			_idxFrmT_1 = 6
			_idxFrmT_2 = 7
		endif

		if	_bMlnTypeR1	then
			_idxFrmT_3 = 4
			_idxFrmT_4 = 3
		endif
		if	_bMlnTypeR2	then
			_idxFrmT_3 = 7
			_idxFrmT_4 = 6
		endif

		!	하부 좌표
		_xTransL_TB = _dxL*_ratioT
		_yTransL_TB = _dyL*_ratioT

		_xTransR_TB = _dxR*_ratioT
		_yTransR_TB = _dyR*_ratioT

		put	_xPosTransL[_idxFrmT_1] + _xTransL_TB,			_yPosTransL[_idxFrmT_1] + _yTransL_TB,	0,
			_xPosTransL[_idxFrmT_2] + _xTransL_TB,			_yPosTransL[_idxFrmT_2] + _yTransL_TB,	0,
			ctwWdt + _xPosTransR[_idxFrmT_3] + _xTransR_TB,	_yPosTransR[_idxFrmT_3] + _yTransR_TB,	0,
			ctwWdt + _xPosTransR[_idxFrmT_4] + _xTransR_TB,	_yPosTransR[_idxFrmT_4] + _yTransR_TB,	0

		!	상부 좌표
		_xTransL_TT = _dxL
		_yTransL_TT = _dyL

		_xTransR_TT = _dxR
		_yTransR_TT = _dyR

		put	_xPosTransL[_idxFrmT_1] + _xTransL_TT,			_yPosTransL[_idxFrmT_1] + _yTransL_TT,	frmWdtT,
			_xPosTransL[_idxFrmT_2] + _xTransL_TT,			_yPosTransL[_idxFrmT_2] + _yTransL_TT,	frmWdtT,
			ctwWdt + _xPosTransR[_idxFrmT_3] + _xTransR_TT,	_yPosTransR[_idxFrmT_3] + _yTransR_TT,	frmWdtT,
			ctwWdt + _xPosTransR[_idxFrmT_4] + _xTransR_TT,	_yPosTransR[_idxFrmT_4] + _yTransR_TT,	frmWdtT

		addz	ctwHgt - frmWdtT
			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
		del 1

	!	개스킷 : Boundary
	if	iFrmTypeT = FrmType_Boundary	then
		!	하부 좌표
		_xTransL_posT = _dxL*_ratioT_pos
		_yTransL_posT = _dyL*_ratioT_pos

		_xTransR_posT = _dxR*_ratioT_pos
		_yTransR_posT = _dyR*_ratioT_pos

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_posT,	_yPosTransL[1] + _yTransL_posT,	0,
				_xPosTransL[2] + _xTransL_posT,	_yPosTransL[2] + _yTransL_posT,	0,
				_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,	0
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_posT,	_yPosTransL[2] + _yTransL_posT,	0,
				_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,	0,
				_xPosTransL[4] + _xTransL_posT,	_yPosTransL[4] + _yTransL_posT,	0,
				_xPosTransL[5] + _xTransL_posT,	_yPosTransL[5] + _yTransL_posT,	0,
				_xPosTransL[6] + _xTransL_posT,	_yPosTransL[6] + _yTransL_posT,	0
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posT,	_yPosTransR[2] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[1] + _xTransR_posT,	_yPosTransR[1] + _yTransR_posT,	0
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_posT,	_yPosTransR[6] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[5] + _xTransR_posT,	_yPosTransR[5] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[4] + _xTransR_posT,	_yPosTransR[4] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posT,	_yPosTransR[2] + _yTransR_posT,	0
		endif

		!	상부 좌표
		_xTransL_gskT = _dxL
		_yTransL_gskT = _dyL

		_xTransR_gskT = _dxR
		_yTransR_gskT = _dyR

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_gskT,	_yPosTransL[1] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[2] + _xTransL_gskT,	_yPosTransL[2] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_gskT,	_yPosTransL[2] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[4] + _xTransL_gskT,	_yPosTransL[4] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[5] + _xTransL_gskT,	_yPosTransL[5] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2,
				_xPosTransL[6] + _xTransL_gskT,	_yPosTransL[6] + _yTransL_gskT,	(frmWdtT + gskWdtT)/2
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[2] + _xTransR_gskT,	_yPosTransR[2] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[1] + _xTransR_gskT,	_yPosTransR[1] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_gskT,	_yPosTransR[6] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[5] + _xTransR_gskT,	_yPosTransR[5] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[4] + _xTransR_gskT,	_yPosTransR[4] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2,
				ctwWdt + _xPosTransR[2] + _xTransR_gskT,	_yPosTransR[2] + _yTransR_gskT,	(frmWdtT + gskWdtT)/2
		endif

		addz	ctwHgt - (frmWdtT + gskWdtT)/2
			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
		del 1
	endif

	!	개스킷 : Transom Type1
	if	(iFrmTypeT = FrmType_Transom) & (iTrsType = Trs_Type1)	then
		!	하부 좌표
		_xTransL_posT = _dxL*_ratioT_pos
		_yTransL_posT = _dyL*_ratioT_pos

		_xTransR_posT = _dxR*_ratioT_pos
		_yTransR_posT = _dyR*_ratioT_pos

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_posT,	_yPosTransL[1] + _yTransL_posT,	0,
				_xPosTransL[2] + _xTransL_posT,	_yPosTransL[2] + _yTransL_posT,	0,
				_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,	0
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_posT,	_yPosTransL[2] + _yTransL_posT,	0,
				_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,	0,
				_xPosTransL[4] + _xTransL_posT,	_yPosTransL[4] + _yTransL_posT,	0,
				_xPosTransL[5] + _xTransL_posT,	_yPosTransL[5] + _yTransL_posT,	0,
				_xPosTransL[6] + _xTransL_posT,	_yPosTransL[6] + _yTransL_posT,	0
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posT,	_yPosTransR[2] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[1] + _xTransR_posT,	_yPosTransR[1] + _yTransR_posT,	0
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_posT,	_yPosTransR[6] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[5] + _xTransR_posT,	_yPosTransR[5] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[4] + _xTransR_posT,	_yPosTransR[4] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,	0,
				ctwWdt + _xPosTransR[2] + _xTransR_posT,	_yPosTransR[2] + _yTransR_posT,	0
		endif

		!	상부 좌표
		_xTransL_gskT = _dxL*_ratioT_gsk
		_yTransL_gskT = _dyL*_ratioT_gsk

		_xTransR_gskT = _dxR*_ratioT_gsk
		_yTransR_gskT = _dyR*_ratioT_gsk

		if	_bMlnTypeL1	then
			put	_xPosTransL[1] + _xTransL_gskT,	_yPosTransL[1] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[2] + _xTransL_gskT,	_yPosTransL[2] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,	gskWdtT
		endif
		if	_bMlnTypeL2	then
			put	_xPosTransL[2] + _xTransL_gskT,	_yPosTransL[2] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[4] + _xTransL_gskT,	_yPosTransL[4] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[5] + _xTransL_gskT,	_yPosTransL[5] + _yTransL_gskT,	gskWdtT,
				_xPosTransL[6] + _xTransL_gskT,	_yPosTransL[6] + _yTransL_gskT,	gskWdtT
		endif

		if	_bMlnTypeR1	then
			put	ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[2] + _xTransR_gskT,	_yPosTransR[2] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[1] + _xTransR_gskT,	_yPosTransR[1] + _yTransR_gskT,	gskWdtT
		endif
		if	_bMlnTypeR2	then
			put	ctwWdt + _xPosTransR[6] + _xTransR_gskT,	_yPosTransR[6] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[5] + _xTransR_gskT,	_yPosTransR[5] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[4] + _xTransR_gskT,	_yPosTransR[4] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,	gskWdtT,
				ctwWdt + _xPosTransR[2] + _xTransR_gskT,	_yPosTransR[2] + _yTransR_gskT,	gskWdtT
		endif

		addz	ctwHgt - (frmWdtT + gskWdtT)/2
			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
		del 1
	endif

	!	개스킷 : Transom Type2
	if	(iFrmTypeT = FrmType_Transom) & (iTrsType = Trs_Type2)	then
		!	개스킷
			!	하부 좌표
			_xTransL_posT = _dxL*_ratioT_pos
			_yTransL_posT = _dyL*_ratioT_pos

			_xTransR_posT = _dxR*_ratioT_pos
			_yTransR_posT = _dyR*_ratioT_pos

			if	_bMlnTypeL1	then
				put	gskWdtL/2 + _xTransL_posT,		gskCapThk/cos(_aFrmL) + _yTransL_posT,	0,
					_xPosTransL[2] + _xTransL_posT,	_yPosTransL[2] + _yTransL_posT,			0,
					_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,			0
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[3] + _xTransL_posT,	_yPosTransL[3] + _yTransL_posT,	0,
					_xPosTransL[4] + _xTransL_posT,	_yPosTransL[4] + _yTransL_posT,	0,
					_xPosTransL[5] + _xTransL_posT,	_yPosTransL[5] + _yTransL_posT,	0,
					_xPosTransL[6] + _xTransL_posT,	_yPosTransL[6] + _yTransL_posT,	0
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,		0,
					ctwWdt + _xPosTransR[2] + _xTransR_posT,	_yPosTransR[2] + _yTransR_posT,		0,
					ctwWdt - gskWdtR/2 + _xTransR_posT,		gskCapThk/cos(_aFrmR) + _yTransR_posT,	0
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_posT,	_yPosTransR[6] + _yTransR_posT,	0,
					ctwWdt + _xPosTransR[5] + _xTransR_posT,	_yPosTransR[5] + _yTransR_posT,	0,
					ctwWdt + _xPosTransR[4] + _xTransR_posT,	_yPosTransR[4] + _yTransR_posT,	0,
					ctwWdt + _xPosTransR[3] + _xTransR_posT,	_yPosTransR[3] + _yTransR_posT,	0
			endif

			!	상부 좌표
			_xTransL_gskT = _dxL*_ratioT_gsk
			_yTransL_gskT = _dyL*_ratioT_gsk

			_xTransR_gskT = _dxR*_ratioT_gsk
			_yTransR_gskT = _dyR*_ratioT_gsk

			if	_bMlnTypeL1	then
				put	gskWdtL/2 + _xTransL_gskT,		gskCapThk/cos(_aFrmL) + _yTransL_gskT,	gskWdtT,
					_xPosTransL[2] + _xTransL_gskT,	_yPosTransL[2] + _yTransL_gskT,			gskWdtT,
					_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,			gskWdtT
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[3] + _xTransL_gskT,	_yPosTransL[3] + _yTransL_gskT,	gskWdtT,
					_xPosTransL[4] + _xTransL_gskT,	_yPosTransL[4] + _yTransL_gskT,	gskWdtT,
					_xPosTransL[5] + _xTransL_gskT,	_yPosTransL[5] + _yTransL_gskT,	gskWdtT,
					_xPosTransL[6] + _xTransL_gskT,	_yPosTransL[6] + _yTransL_gskT,	gskWdtT
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,		gskWdtT,
					ctwWdt + _xPosTransR[2] + _xTransR_gskT,	_yPosTransR[2] + _yTransR_gskT,		gskWdtT,
					ctwWdt - gskWdtR/2 + _xTransR_gskT,		gskCapThk/cos(_aFrmR) + _yTransR_gskT,	gskWdtT
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_gskT,	_yPosTransR[6] + _yTransR_gskT,	gskWdtT,
					ctwWdt + _xPosTransR[5] + _xTransR_gskT,	_yPosTransR[5] + _yTransR_gskT,	gskWdtT,
					ctwWdt + _xPosTransR[4] + _xTransR_gskT,	_yPosTransR[4] + _yTransR_gskT,	gskWdtT,
					ctwWdt + _xPosTransR[3] + _xTransR_gskT,	_yPosTransR[3] + _yTransR_gskT,	gskWdtT
			endif

			addz	ctwHgt - (frmWdtT + gskWdtT)/2
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1

		!	개스킷 캡
			!	하부 좌표
			_xTransL_capB = _dxL*_ratioT
			_yTransL_capB = _dyL*_ratioT

			_xTransR_capB = _dxR*_ratioT
			_yTransR_capB = _dyR*_ratioT

			if	_bMlnTypeL1	then
				put	_xPosTransL[1] + _xTransL_capB,	_yPosTransL[1] + _yTransL_capB,			0,
					gskWdtL/2 + _xTransL_capB,		gskCapThk/cos(_aFrmL) + _yTransL_capB,	0
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2] + _xTransL_capB,	_yPosTransL[2] + _yTransL_capB,	0,
					_xPosTransL[3] + _xTransL_capB,	_yPosTransL[3] + _yTransL_capB,	0
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt - gskWdtR/2 + _xTransR_capB,			gskCapThk/cos(_aFrmR) + _yTransR_capB,	0,
					ctwWdt + _xPosTransR[1] + _xTransR_capB,	_yPosTransR[1] + _yTransR_capB,			0
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_capB,	_yPosTransR[3] + _yTransR_capB,	0,
					ctwWdt + _xPosTransR[2] + _xTransR_capB,	_yPosTransR[2] + _yTransR_capB,	0
			endif

			!	상부 좌표
			_xTransL_capT = _dxL
			_yTransL_capT = _dyL

			_xTransR_capT = _dxR
			_yTransR_capT = _dyR

			if	_bMlnTypeL1	then
				put	_xPosTransL[1] + _xTransL_capT,	_yPosTransL[1] + _yTransL_capT,			frmWdtT,
					gskWdtL/2 + _xTransL_capT,		gskCapThk/cos(_aFrmL) + _yTransL_capT,	frmWdtT
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2] + _xTransL_capT,	_yPosTransL[2] + _yTransL_capT,	frmWdtT,
					_xPosTransL[3] + _xTransL_capT,	_yPosTransL[3] + _yTransL_capT,	frmWdtT
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt - gskWdtR/2 + _xTransR_capT,			gskCapThk/cos(_aFrmR) + _yTransR_capT,	frmWdtT,
					ctwWdt + _xPosTransR[1] + _xTransR_capT,	_yPosTransR[1] + _yTransR_capT,			frmWdtT
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_capT,	_yPosTransR[3] + _yTransR_capT,	frmWdtT,
					ctwWdt + _xPosTransR[2] + _xTransR_capT,	_yPosTransR[2] + _yTransR_capT,	frmWdtT
			endif

			addz	ctwHgt - frmWdtT
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1
	endif
endif

!===============================================================================================
!	트랜섬
!===============================================================================================
pen			frmPen_Elev
sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmPen_Sect
material	frmMat

if	not(nTrs < eps)	then
	!	프레임
	for	i = 1	to	nTrs
		!	멀리언 타입에 따른 index
		if	_bMlnTypeL1	then
			_idxTrs_1 = 3
			_idxTrs_2 = 4
		endif
		if	_bMlnTypeL2	then
			_idxTrs_1 = 6
			_idxTrs_2 = 7
		endif

		if	_bMlnTypeR1	then
			_idxTrs_3 = 4
			_idxTrs_4 = 3
		endif
		if	_bMlnTypeR2	then
			_idxTrs_3 = 7
			_idxTrs_4 = 6
		endif

		_ratio_trsB = (trsGap[i] - trsWdt/2)/ctwHgt
		_ratio_trsT = (trsGap[i] + trsWdt/2)/ctwHgt

		!	하부 좌표
		_xTransL_trsB = _dxL*_ratio_trsB
		_yTransL_trsB = _dyL*_ratio_trsB

		_xTransR_trsB = _dxR*_ratio_trsB
		_yTransR_trsB = _dyR*_ratio_trsB

		put	_xPosTransL[_idxTrs_1] + _xTransL_trsB,				_yPosTransL[_idxTrs_1] + _yTransL_trsB,	0,
			_xPosTransL[_idxTrs_2] + _xTransL_trsB,				_yPosTransL[_idxTrs_2] + _yTransL_trsB,	0,
			ctwWdt + _xPosTransR[_idxTrs_3] + _xTransR_trsB,	_yPosTransR[_idxTrs_3] + _yTransR_trsB,	0,
			ctwWdt + _xPosTransR[_idxTrs_4] + _xTransR_trsB,	_yPosTransR[_idxTrs_4] + _yTransR_trsB,	0

		!	상부 좌표
		_xTransL_trsT = _dxL*_ratio_trsT
		_yTransL_trsT = _dyL*_ratio_trsT

		_xTransR_trsT = _dxR*_ratio_trsT
		_yTransR_trsT = _dyR*_ratio_trsT

		put	_xPosTransL[_idxTrs_1] + _xTransL_trsT,				_yPosTransL[_idxTrs_1] + _yTransL_trsT,	trsWdt,
			_xPosTransL[_idxTrs_2] + _xTransL_trsT,				_yPosTransL[_idxTrs_2] + _yTransL_trsT,	trsWdt,
			ctwWdt + _xPosTransR[_idxTrs_3] + _xTransR_trsT,	_yPosTransR[_idxTrs_3] + _yTransR_trsT,	trsWdt,
			ctwWdt + _xPosTransR[_idxTrs_4] + _xTransR_trsT,	_yPosTransR[_idxTrs_4] + _yTransR_trsT,	trsWdt

		addz	trsGap[i] - trsWdt/2
			ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
		del 1
	next	i

	!	개스킷
	for	i = 1	to	nTrs
		_ratio_trsB = (trsGap[i] - trsWdt/2)/ctwHgt
		_ratio_trsT = (trsGap[i] + trsWdt/2)/ctwHgt
		_ratio_trsGskB = (trsGap[i] - trsGskWdt/2)/ctwHgt
		_ratio_trsGskT = (trsGap[i] + trsGskWdt/2)/ctwHgt

		if	iTrsType = Trs_Type1	then
			!	하부 좌표
			_xTransL_trsGskB = _dxL*_ratio_trsGskB
			_yTransL_trsGskB = _dyL*_ratio_trsGskB

			_xTransR_trsGskB = _dxR*_ratio_trsGskB
			_yTransR_trsGskB = _dyR*_ratio_trsGskB

			if	_bMlnTypeL1	then
				put	_xPosTransL[1] + _xTransL_trsGskB,	_yPosTransL[1] + _yTransL_trsGskB,	0,
					_xPosTransL[2] + _xTransL_trsGskB,	_yPosTransL[2] + _yTransL_trsGskB,	0,
					_xPosTransL[3] + _xTransL_trsGskB,	_yPosTransL[3] + _yTransL_trsGskB,	0
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2] + _xTransL_trsGskB,	_yPosTransL[2] + _yTransL_trsGskB,	0,
					_xPosTransL[3] + _xTransL_trsGskB,	_yPosTransL[3] + _yTransL_trsGskB,	0,
					_xPosTransL[4] + _xTransL_trsGskB,	_yPosTransL[4] + _yTransL_trsGskB,	0,
					_xPosTransL[5] + _xTransL_trsGskB,	_yPosTransL[5] + _yTransL_trsGskB,	0,
					_xPosTransL[6] + _xTransL_trsGskB,	_yPosTransL[6] + _yTransL_trsGskB,	0
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_trsGskB,	_yPosTransR[3] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[2] + _xTransR_trsGskB,	_yPosTransR[2] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[1] + _xTransR_trsGskB,	_yPosTransR[1] + _yTransR_trsGskB,	0
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_trsGskB,	_yPosTransR[6] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[5] + _xTransR_trsGskB,	_yPosTransR[5] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[4] + _xTransR_trsGskB,	_yPosTransR[4] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[3] + _xTransR_trsGskB,	_yPosTransR[3] + _yTransR_trsGskB,	0,
					ctwWdt + _xPosTransR[2] + _xTransR_trsGskB,	_yPosTransR[2] + _yTransR_trsGskB,	0
			endif

			!	상부 좌표
			_xTransL_trsGskT = _dxL*_ratio_trsGskT
			_yTransL_trsGskT = _dyL*_ratio_trsGskT

			_xTransR_trsGskT = _dxR*_ratio_trsGskT
			_yTransR_trsGskT = _dyR*_ratio_trsGskT

			if	_bMlnTypeL1	then
				put	_xPosTransL[1] + _xTransL_trsGskT,	_yPosTransL[1] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[2] + _xTransL_trsGskT,	_yPosTransL[2] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[3] + _xTransL_trsGskT,	_yPosTransL[3] + _yTransL_trsGskT,	trsGskWdt
			endif
			if	_bMlnTypeL2	then
				put	_xPosTransL[2] + _xTransL_trsGskT,	_yPosTransL[2] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[3] + _xTransL_trsGskT,	_yPosTransL[3] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[4] + _xTransL_trsGskT,	_yPosTransL[4] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[5] + _xTransL_trsGskT,	_yPosTransL[5] + _yTransL_trsGskT,	trsGskWdt,
					_xPosTransL[6] + _xTransL_trsGskT,	_yPosTransL[6] + _yTransL_trsGskT,	trsGskWdt
			endif

			if	_bMlnTypeR1	then
				put	ctwWdt + _xPosTransR[3] + _xTransR_trsGskT,	_yPosTransR[3] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[2] + _xTransR_trsGskT,	_yPosTransR[2] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[1] + _xTransR_trsGskT,	_yPosTransR[1] + _yTransR_trsGskT,	trsGskWdt
			endif
			if	_bMlnTypeR2	then
				put	ctwWdt + _xPosTransR[6] + _xTransR_trsGskT,	_yPosTransR[6] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[5] + _xTransR_trsGskT,	_yPosTransR[5] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[4] + _xTransR_trsGskT,	_yPosTransR[4] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[3] + _xTransR_trsGskT,	_yPosTransR[3] + _yTransR_trsGskT,	trsGskWdt,
					ctwWdt + _xPosTransR[2] + _xTransR_trsGskT,	_yPosTransR[2] + _yTransR_trsGskT,	trsGskWdt
			endif

			addz	trsGap[i] - trsGskWdt/2
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1
		endif

		if	iTrsType = Trs_Type2	then
			!	개스킷
				!	하부 좌표
				_xTransL_trsGskB = _dxL*_ratio_trsGskB
				_yTransL_trsGskB = _dyL*_ratio_trsGskB

				_xTransR_trsGskB = _dxR*_ratio_trsGskB
				_yTransR_trsGskB = _dyR*_ratio_trsGskB

				if	_bMlnTypeL1	then
					put	gskWdtL/2 + _xTransL_trsGskB,		gskCapThk/cos(_aFrmL) + _yTransL_trsGskB,	0,
						_xPosTransL[2] + _xTransL_trsGskB,	_yPosTransL[2] + _yTransL_trsGskB,			0,
						_xPosTransL[3] + _xTransL_trsGskB,	_yPosTransL[3] + _yTransL_trsGskB,			0
				endif
				if	_bMlnTypeL2	then
					put	_xPosTransL[3] + _xTransL_trsGskB,	_yPosTransL[3] + _yTransL_trsGskB,	0,
						_xPosTransL[4] + _xTransL_trsGskB,	_yPosTransL[4] + _yTransL_trsGskB,	0,
						_xPosTransL[5] + _xTransL_trsGskB,	_yPosTransL[5] + _yTransL_trsGskB,	0,
						_xPosTransL[6] + _xTransL_trsGskB,	_yPosTransL[6] + _yTransL_trsGskB,	0
				endif

				if	_bMlnTypeR1	then
					put	ctwWdt + _xPosTransR[3] + _xTransR_trsGskB,	_yPosTransR[3] + _yTransR_trsGskB,			0,
						ctwWdt + _xPosTransR[2] + _xTransR_trsGskB,	_yPosTransR[2] + _yTransR_trsGskB,			0,
						ctwWdt - gskWdtR/2 + _xTransR_trsGskB,		gskCapThk/cos(_aFrmR) + _yTransR_trsGskB,	0
				endif
				if	_bMlnTypeR2	then
					put	ctwWdt + _xPosTransR[6] + _xTransR_trsGskB,	_yPosTransR[6] + _yTransR_trsGskB,	0,
						ctwWdt + _xPosTransR[5] + _xTransR_trsGskB,	_yPosTransR[5] + _yTransR_trsGskB,	0,
						ctwWdt + _xPosTransR[4] + _xTransR_trsGskB,	_yPosTransR[4] + _yTransR_trsGskB,	0,
						ctwWdt + _xPosTransR[3] + _xTransR_trsGskB,	_yPosTransR[3] + _yTransR_trsGskB,	0
				endif

				!	상부 좌표
				_xTransL_trsGskT = _dxL*_ratio_trsGskT
				_yTransL_trsGskT = _dyL*_ratio_trsGskT

				_xTransR_trsGskT = _dxR*_ratio_trsGskT
				_yTransR_trsGskT = _dyR*_ratio_trsGskT

				if	_bMlnTypeL1	then
					put	gskWdtL/2 + _xTransL_trsGskT,		gskCapThk/cos(_aFrmL) + _yTransL_trsGskT,	trsGskWdt,
						_xPosTransL[2] + _xTransL_trsGskT,	_yPosTransL[2] + _yTransL_trsGskT,			trsGskWdt,
						_xPosTransL[3] + _xTransL_trsGskT,	_yPosTransL[3] + _yTransL_trsGskT,			trsGskWdt
				endif
				if	_bMlnTypeL2	then
					put	_xPosTransL[3] + _xTransL_trsGskT,	_yPosTransL[3] + _yTransL_trsGskT,	trsGskWdt,
						_xPosTransL[4] + _xTransL_trsGskT,	_yPosTransL[4] + _yTransL_trsGskT,	trsGskWdt,
						_xPosTransL[5] + _xTransL_trsGskT,	_yPosTransL[5] + _yTransL_trsGskT,	trsGskWdt,
						_xPosTransL[6] + _xTransL_trsGskT,	_yPosTransL[6] + _yTransL_trsGskT,	trsGskWdt
				endif

				if	_bMlnTypeR1	then
					put	ctwWdt + _xPosTransR[3] + _xTransR_trsGskT,	_yPosTransR[3] + _yTransR_trsGskT,			trsGskWdt,
						ctwWdt + _xPosTransR[2] + _xTransR_trsGskT,	_yPosTransR[2] + _yTransR_trsGskT,			trsGskWdt,
						ctwWdt - gskWdtR/2 + _xTransR_trsGskT,		gskCapThk/cos(_aFrmR) + _yTransR_trsGskT,	trsGskWdt
				endif
				if	_bMlnTypeR2	then
					put	ctwWdt + _xPosTransR[6] + _xTransR_trsGskT,	_yPosTransR[6] + _yTransR_trsGskT,	trsGskWdt,
						ctwWdt + _xPosTransR[5] + _xTransR_trsGskT,	_yPosTransR[5] + _yTransR_trsGskT,	trsGskWdt,
						ctwWdt + _xPosTransR[4] + _xTransR_trsGskT,	_yPosTransR[4] + _yTransR_trsGskT,	trsGskWdt,
						ctwWdt + _xPosTransR[3] + _xTransR_trsGskT,	_yPosTransR[3] + _yTransR_trsGskT,	trsGskWdt
				endif

				addz	trsGap[i] - trsGskWdt/2
					ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
				del 1

			!	개스킷 캡
				!	하부 좌표
				_xTransL_trsCapB = _dxL*_ratio_trsB
				_yTransL_trsCapB = _dyL*_ratio_trsB

				_xTransR_trsCapB = _dxR*_ratio_trsB
				_yTransR_trsCapB = _dyR*_ratio_trsB

				if	_bMlnTypeL1	then
					put	_xPosTransL[1] + _xTransL_trsCapB,	_yPosTransL[1] + _yTransL_trsCapB,			0,
						gskWdtL/2 + _xTransL_trsCapB,		gskCapThk/cos(_aFrmL) + _yTransL_trsCapB,	0
				endif
				if	_bMlnTypeL2	then
					put	_xPosTransL[2] + _xTransL_trsCapB,	_yPosTransL[2] + _yTransL_trsCapB,	0,
						_xPosTransL[3] + _xTransL_trsCapB,	_yPosTransL[3] + _yTransL_trsCapB,	0
				endif

				if	_bMlnTypeR1	then
					put	ctwWdt - gskWdtR/2 + _xTransR_trsCapB,		gskCapThk/cos(_aFrmR) + _yTransR_trsCapB,	0,
						ctwWdt + _xPosTransR[1] + _xTransR_trsCapB,	_yPosTransR[1] + _yTransR_trsCapB,			0
				endif
				if	_bMlnTypeR2	then
					put	ctwWdt + _xPosTransR[3] + _xTransR_trsCapB,	_yPosTransR[3] + _yTransR_trsCapB,	0,
						ctwWdt + _xPosTransR[2] + _xTransR_trsCapB,	_yPosTransR[2] + _yTransR_trsCapB,	0
				endif

				!	상부 좌표
				_xTransL_trsCapT = _dxL*_ratio_trsT
				_yTransL_trsCapT = _dyL*_ratio_trsT

				_xTransR_trsCapT = _dxR*_ratio_trsT
				_yTransR_trsCapT = _dyR*_ratio_trsT

				if	_bMlnTypeL1	then
					put	_xPosTransL[1] + _xTransL_trsCapT,	_yPosTransL[1] + _yTransL_trsCapT,			trsWdt,
						gskWdtL/2 + _xTransL_trsCapT,		gskCapThk/cos(_aFrmL) + _yTransL_trsCapT,	trsWdt
				endif
				if	_bMlnTypeL2	then
					put	_xPosTransL[2] + _xTransL_trsCapT,	_yPosTransL[2] + _yTransL_trsCapT,	trsWdt,
						_xPosTransL[3] + _xTransL_trsCapT,	_yPosTransL[3] + _yTransL_trsCapT,	trsWdt
				endif

				if	_bMlnTypeR1	then
					put	ctwWdt - gskWdtR/2 + _xTransR_trsCapT,		gskCapThk/cos(_aFrmR) + _yTransR_trsCapT,	trsWdt,
						ctwWdt + _xPosTransR[1] + _xTransR_trsCapT,	_yPosTransR[1] + _yTransR_trsCapT,			trsWdt
				endif
				if	_bMlnTypeR2	then
					put	ctwWdt + _xPosTransR[3] + _xTransR_trsCapT,	_yPosTransR[3] + _yTransR_trsCapT,	trsWdt,
						ctwWdt + _xPosTransR[2] + _xTransR_trsCapT,	_yPosTransR[2] + _yTransR_trsCapT,	trsWdt
				endif

				addz	trsGap[i] - trsWdt/2
					ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
				del 1
		endif
	next	i
endif


!===============================================================================================
!	수평프레임 캡
!===============================================================================================
pen			frmPen_Elev
sect_fill	frmFill,	frmBackPen,	frmFillPen,	frmPen_Sect
material	frmMat

if	not(nTrs < eps)	then
	!	프레임
	for	i = 1	to	nTrs
		!	멀리언 타입에 따른 index
		if	_bMlnTypeL1	then
			_idxTrsCap_1 = 3
			_idxTrsCap_2 = 4
		endif
		if	_bMlnTypeL2	then
			_idxTrsCap_1 = 6
			_idxTrsCap_2 = 7
		endif

		if	_bMlnTypeR1	then
			_idxTrsCap_3 = 4
			_idxTrsCap_4 = 3
		endif
		if	_bMlnTypeR2	then
			_idxTrsCap_3 = 7
			_idxTrsCap_4 = 6
		endif

		if	bTrsCap[i]	then
			_ratio_trsCapB = (trsGap[i] - trsCapWdt/2)/ctwHgt
			_ratio_trsCapT = (trsGap[i] + trsCapWdt/2)/ctwHgt

			!	하부 좌표
			_xTransL_trsB = _dxL*_ratio_trsCapB
			_yTransL_trsB = _dyL*_ratio_trsCapB

			_xTransR_trsB = _dxR*_ratio_trsCapB
			_yTransR_trsB = _dyR*_ratio_trsCapB

			put	_xPosTransL[1] - (gskWdtL/2/cos(_aFrmL) + trsCapThk*tan(_aFrmL)) + _xTransL_trsB,			_yPosTransL[1] - trsCapThk + _yTransL_trsB,				0,
				_xPosTransL[1] - gskWdtL/2*cos(_aFrmL) + _xTransL_trsB,										_yPosTransL[1] + gskWdtL/2*sin(_aFrmL) + _yTransL_trsB,	0,
				_xPosTransL[1] + _xTransL_trsB,																_yPosTransL[1] + _yTransL_trsB,							0,
				ctwWdt + _xPosTransR[1] + _xTransR_trsB,													_yPosTransR[1] + _yTransR_trsB,							0,
				ctwWdt + _xPosTransR[1] + gskWdtR/2*cos(_aFrmR) + _xTransR_trsB,							_yPosTransR[1] + gskWdtR/2*sin(_aFrmR) + _yTransR_trsB,	0,
				ctwWdt + _xPosTransR[1] + gskWdtR/2/cos(_aFrmR) + trsCapThk*tan(_aFrmR) + _xTransR_trsB,	_yPosTransR[1] - trsCapThk + _yTransR_trsB,				0

			!	상부 좌표
			_xTransL_trsT = _dxL*_ratio_trsCapT
			_yTransL_trsT = _dyL*_ratio_trsCapT

			_xTransR_trsT = _dxR*_ratio_trsCapT
			_yTransR_trsT = _dyR*_ratio_trsCapT

			put	_xPosTransL[1] - (gskWdtL/2/cos(_aFrmL) + trsCapThk*tan(_aFrmL)) + _xTransL_trsT,			_yPosTransL[1] - trsCapThk + _yTransL_trsT,					trsCapWdt,
				_xPosTransL[1] - (gskWdtL/2*cos(_aFrmL)) + _xTransL_trsT,									_yPosTransL[1] + (gskWdtL/2*sin(_aFrmL)) + _yTransL_trsT,	trsCapWdt,
				_xPosTransL[1] + _xTransL_trsT,																_yPosTransL[1] + _yTransL_trsT,								trsCapWdt,
				ctwWdt + _xPosTransR[1] + _xTransR_trsT,													_yPosTransR[1] + _yTransR_trsT,								trsCapWdt,
				ctwWdt + _xPosTransR[1] + gskWdtR/2*cos(_aFrmR) + _xTransR_trsT,							_yPosTransR[1] + gskWdtR/2*sin(_aFrmR) + _yTransR_trsT,		trsCapWdt,
				ctwWdt + _xPosTransR[1] + gskWdtR/2/cos(_aFrmR) + trsCapThk*tan(_aFrmR) + _xTransR_trsT,	_yPosTransR[1] - trsCapThk + _yTransR_trsT,					trsCapWdt

			addz	trsGap[i] - trsCapWdt/2
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1
		endif
	next	i
endif


!===============================================================================================
!	패널
!===============================================================================================
pen			pnlPen_Elev
sect_fill	pnlFill,	pnlBackPen,	pnlFillPen,	pnlPen_Sect

!	멀리언 타입에 따른 index
if	_bMlnTypeL1	then
	_idxPnl_1 = 2
	_idxPnl_2 = 3
endif
if	_bMlnTypeL2	then
	_idxPnl_1 = 5
	_idxPnl_2 = 6
endif

if	_bMlnTypeR1	then
	_idxPnl_3 = 3
	_idxPnl_4 = 2
endif
if	_bMlnTypeR2	then
	_idxPnl_3 = 6
	_idxPnl_4 = 5
endif

for	i = 1	to	nTrs + 1
	if	iInsType[i] = INS_TYPE_NONE	then	material	pnlMat
	if	iInsType[i] = INS_TYPE_1	then	material	spdGlsMat_1
	if	iInsType[i] = INS_TYPE_2	then	material	spdGlsMat_2
	if	iInsType[i] = INS_TYPE_3	then	material	spdGlsMat_3
	if	iInsType[i] = INS_TYPE_4	then	material	spdGlsMat_4

	!	Panel Height/zPosPnl
	!-----------------------------------------------------------------------------------------------
	if	nTrs < eps	then
		_pnlHgt = ctwHgt - ((frmWdtB + gskWdtB)/2 + (frmWdtT + gskWdtT)/2)
		_zPosPnl = (frmWdtB + gskWdtB)/2
	else
		if	i = 1	then
			_pnlHgt = trsGap[i] - ((frmWdtB + gskWdtB)/2 + trsGskWdt/2)
			_zPosPnl = (frmWdtB + gskWdtB)/2
		endif

		if	i # 1 & i # (nTrs + 1)	then
			_pnlHgt = (trsGap[i] - trsGap[i - 1]) - trsGskWdt
			_zPosPnl = trsGap[i - 1] + trsGskWdt/2
		endif

		if	i = (nTrs + 1)	then
			_pnlHgt = (ctwHgt - trsGap[i - 1]) - ((frmWdtT + gskWdtT)/2 + trsGskWdt/2)
			_zPosPnl = trsGap[i - 1] + trsGskWdt/2
		endif
	endif

	!	비율
	!-----------------------------------------------------------------------------------------------
	if	nTrs < eps	then
		_ratio_pnlB = ((frmWdtB + gskWdtB)/2)/ctwHgt
		_ratio_pnlT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
	else
		if	i = 1	then
			_ratio_pnlB = ((frmWdtB + gskWdtB)/2)/ctwHgt
			_ratio_pnlT = (trsGap[i] - trsGskWdt/2)/ctwHgt
		endif

		if	i # 1 & i # (nTrs + 1)	then
			_ratio_pnlB = (trsGap[i - 1] + trsGskWdt/2)/ctwHgt
			_ratio_pnlT = (trsGap[i] - trsGskWdt/2)/ctwHgt
		endif

		if	i = (nTrs + 1)	then
			_ratio_pnlB = (trsGap[i - 1] + trsGskWdt/2)/ctwHgt
			_ratio_pnlT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
		endif
	endif

	!	하부 좌표
	!-----------------------------------------------------------------------------------------------
		!	좌측 좌표
		_xTransL_pnlB = _dxL*_ratio_pnlB
		_yTransL_pnlB = _dyL*_ratio_pnlB

		if	iFrmTypeL = FrmType_Boundary	then
			_xPosL_pnlB1 = (frmWdtL + gskWdtL)/2
			_yPosL_pnlB1 = gskThk - pnlThk

			_xPosL_pnlB2 = (frmWdtL + gskWdtL)/2
			_yPosL_pnlB2 = gskThk

			put	_xPosL_pnlB1 + _xTransL_pnlB,	_yPosL_pnlB1 + _yTransL_pnlB,	0,
				_xPosL_pnlB2 + _xTransL_pnlB,	_yPosL_pnlB2 + _yTransL_pnlB,	0
		endif

		if	iFrmTypeL = FrmType_Mullion	then
			_xPosL_pnlB1 = (gskWdtL/2)*cos(aFrmL) - ((gskThk - pnlThk)/cos(aFrmL))*sin(aFrmL) + _xPosL_refer + pnlLct*tan(aFrmL)
			_yPosL_pnlB1 = (gskWdtL/2)*sin(aFrmL) + ((gskThk - pnlThk)/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

			_xPosL_pnlB2 = (gskWdtL/2)*cos(aFrmL) - (gskThk/cos(aFrmL))*sin(aFrmL) + _xPosL_refer + pnlLct*tan(aFrmL)
			_yPosL_pnlB2 = (gskWdtL/2)*sin(aFrmL) + (gskThk/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

			if	_yPosTransL[_idxPnl_1] < _yPosL_pnlB2	then
				if	_yPosTransL[_idxPnl_1] > _yPosL_pnlB1	then
					_xPosL_pnlB1 = (gskWdtL/2)*cos(aFrmL) - ((gskThk - pnlThk)/cos(aFrmL))*sin(aFrmL) + _xPosL_refer
					_yPosL_pnlB1 = (gskWdtL/2)*sin(aFrmL) + ((gskThk - pnlThk)/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

					_xPosL_pnlB2 = _xPosTransL[_idxPnl_1]
					_yPosL_pnlB2 = _yPosTransL[_idxPnl_1]

					_xPosL_pnlB3 = _xPosTransL[_idxPnl_2]
					_yPosL_pnlB3 = _yPosTransL[_idxPnl_2]

					put	_xPosL_pnlB1 + _xTransL_pnlB,	_yPosL_pnlB1 + _yTransL_pnlB,	0,
						_xPosL_pnlB2 + _xTransL_pnlB,	_yPosL_pnlB2 + _yTransL_pnlB,	0,
						_xPosL_pnlB3 + _xTransL_pnlB,	_yPosL_pnlB3 + _yTransL_pnlB,	0
				else
					_xPosL_pnlB1 = _xPosTransL[_idxPnl_2] - pnlThk/tan(aFrmL)
					_yPosL_pnlB1 = _yPosTransL[_idxPnl_2] - pnlThk

					_xPosL_pnlB2 = _xPosTransL[_idxPnl_2]
					_yPosL_pnlB2 = _yPosTransL[_idxPnl_2]

					put	_xPosL_pnlB1 + _xTransL_pnlB,	_yPosL_pnlB1 + _yTransL_pnlB,	0,
						_xPosL_pnlB2 + _xTransL_pnlB,	_yPosL_pnlB2 + _yTransL_pnlB,	0
				endif
			else
				put	_xPosL_pnlB1 + _xTransL_pnlB,	_yPosL_pnlB1 + _yTransL_pnlB,	0,
					_xPosL_pnlB2 + _xTransL_pnlB,	_yPosL_pnlB2 + _yTransL_pnlB,	0
			endif
		endif

		!	우측 좌표
		_xTransR_pnlB = _dxR*_ratio_pnlB
		_yTransR_pnlB = _dyR*_ratio_pnlB

		if	iFrmTypeR = FrmType_Boundary	then
			_xPosR_pnlB1 = -(frmWdtR + gskWdtR)/2
			_yPosR_pnlB1 = gskThk

			_xPosR_pnlB2 = -(frmWdtR + gskWdtR)/2
			_yPosR_pnlB2 = gskThk - pnlThk

			put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlB,	_yPosR_pnlB1 + _yTransR_pnlB,	0,
				ctwWdt + _xPosR_pnlB2 + _xTransR_pnlB,	_yPosR_pnlB2 + _yTransR_pnlB,	0
		endif

		if	iFrmTypeR = FrmType_Mullion	then
			_xPosR_pnlB1 = (-gskWdtR/2)*cos(aFrmR) - (gskThk/cos(aFrmR))*sin(aFrmR) - _xPosR_refer + pnlLct*tan(aFrmR)
			_yPosR_pnlB1 = (-gskWdtR/2)*sin(aFrmR) + (gskThk/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

			_xPosR_pnlB2 = (-gskWdtR/2)*cos(aFrmR) - ((gskThk - pnlThk)/cos(aFrmR))*sin(aFrmR) - _xPosR_refer + pnlLct*tan(aFrmR)
			_yPosR_pnlB2 = (-gskWdtR/2)*sin(aFrmR) + ((gskThk - pnlThk)/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

			if	_yPosTransR[_idxPnl_4] < _yPosR_pnlB1	then
				if	_yPosTransR[_idxPnl_4] > _yPosR_pnlB2	then
					_xPosR_pnlB1 = _xPosTransR[_idxPnl_3]
					_yPosR_pnlB1 = _yPosTransR[_idxPnl_3]

					_xPosR_pnlB2 = _xPosTransR[_idxPnl_4]
					_yPosR_pnlB2 = _yPosTransR[_idxPnl_4]

					_xPosR_pnlB3 = (-gskWdtR/2)*cos(aFrmR) - ((gskThk - pnlThk)/cos(aFrmR))*sin(aFrmR) - _xPosR_refer
					_yPosR_pnlB3 = (-gskWdtR/2)*sin(aFrmR) + ((gskThk - pnlThk)/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

					put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlB,	_yPosR_pnlB1 + _yTransR_pnlB,	0,
						ctwWdt + _xPosR_pnlB2 + _xTransR_pnlB,	_yPosR_pnlB2 + _yTransR_pnlB,	0,
						ctwWdt + _xPosR_pnlB3 + _xTransR_pnlB,	_yPosR_pnlB3 + _yTransR_pnlB,	0
				else
					_xPosR_pnlB1 = _xPosTransR[_idxPnl_3]
					_yPosR_pnlB1 = _yPosTransR[_idxPnl_3]

					_xPosR_pnlB2 = _xPosTransR[_idxPnl_3] - pnlThk/tan(aFrmR)
					_yPosR_pnlB2 = _yPosTransR[_idxPnl_3] - pnlThk

					put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlB,	_yPosR_pnlB1 + _yTransR_pnlB,	0,
						ctwWdt + _xPosR_pnlB2 + _xTransR_pnlB,	_yPosR_pnlB2 + _yTransR_pnlB,	0
				endif
			else
				put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlB,	_yPosR_pnlB1 + _yTransR_pnlB,	0,
					ctwWdt + _xPosR_pnlB2 + _xTransR_pnlB,	_yPosR_pnlB2 + _yTransR_pnlB,	0
			endif
		endif


	!	상부 좌표
	!-----------------------------------------------------------------------------------------------
		!	좌측 좌표
		_xTransL_pnlT = _dxL*_ratio_pnlT
		_yTransL_pnlT = _dyL*_ratio_pnlT

		if	iFrmTypeL = FrmType_Boundary	then
			_xPosL_pnlT1 = (frmWdtL + gskWdtL)/2
			_yPosL_pnlT1 = gskThk - pnlThk

			_xPosL_pnlT2 = (frmWdtL + gskWdtL)/2
			_yPosL_pnlT2 = gskThk

			put	_xPosL_pnlT1 + _xTransL_pnlT,	_yPosL_pnlT1 + _yTransL_pnlT,	_pnlHgt,
				_xPosL_pnlT2 + _xTransL_pnlT,	_yPosL_pnlT2 + _yTransL_pnlT,	_pnlHgt
		endif

		if	iFrmTypeL = FrmType_Mullion	then
			_xPosL_pnlT1 = (gskWdtL/2)*cos(aFrmL) - ((gskThk - pnlThk)/cos(aFrmL))*sin(aFrmL) + _xPosL_refer + pnlLct*tan(aFrmL)
			_yPosL_pnlT1 = (gskWdtL/2)*sin(aFrmL) + ((gskThk - pnlThk)/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

			_xPosL_pnlT2 = (gskWdtL/2)*cos(aFrmL) - (gskThk/cos(aFrmL))*sin(aFrmL) + _xPosL_refer + pnlLct*tan(aFrmL)
			_yPosL_pnlT2 = (gskWdtL/2)*sin(aFrmL) + (gskThk/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

			if	_yPosTransL[_idxPnl_1] < _yPosL_pnlT2	then
				if	_yPosTransL[_idxPnl_1] > _yPosL_pnlT1	then
					_xPosL_pnlT1 = (gskWdtL/2)*cos(aFrmL) - ((gskThk - pnlThk)/cos(aFrmL))*sin(aFrmL) + _xPosL_refer
					_yPosL_pnlT1 = (gskWdtL/2)*sin(aFrmL) + ((gskThk - pnlThk)/cos(aFrmL))*cos(aFrmL) + _yPosL_refer

					_xPosL_pnlT2 = _xPosTransL[_idxPnl_1]
					_yPosL_pnlT2 = _yPosTransL[_idxPnl_1]

					_xPosL_pnlT3 = _xPosTransL[_idxPnl_2]
					_yPosL_pnlT3 = _yPosTransL[_idxPnl_2]

					put	_xPosL_pnlT1 + _xTransL_pnlT,	_yPosL_pnlT1 + _yTransL_pnlT,	_pnlHgt,
						_xPosL_pnlT2 + _xTransL_pnlT,	_yPosL_pnlT2 + _yTransL_pnlT,	_pnlHgt,
						_xPosL_pnlT3 + _xTransL_pnlT,	_yPosL_pnlT3 + _yTransL_pnlT,	_pnlHgt
				else
					_xPosL_pnlT1 = _xPosTransL[_idxPnl_2] - pnlThk/tan(aFrmL)
					_yPosL_pnlT1 = _yPosTransL[_idxPnl_2] - pnlThk

					_xPosL_pnlT2 = _xPosTransL[_idxPnl_2]
					_yPosL_pnlT2 = _yPosTransL[_idxPnl_2]

					put	_xPosL_pnlT1 + _xTransL_pnlT,	_yPosL_pnlT1 + _yTransL_pnlT,	_pnlHgt,
						_xPosL_pnlT2 + _xTransL_pnlT,	_yPosL_pnlT2 + _yTransL_pnlT,	_pnlHgt
				endif
			else
				put	_xPosL_pnlT1 + _xTransL_pnlT,	_yPosL_pnlT1 + _yTransL_pnlT,	_pnlHgt,
					_xPosL_pnlT2 + _xTransL_pnlT,	_yPosL_pnlT2 + _yTransL_pnlT,	_pnlHgt
			endif
		endif

		!	우측 좌표
		_xTransR_pnlT = _dxR*_ratio_pnlT
		_yTransR_pnlT = _dyR*_ratio_pnlT

		if	iFrmTypeR = FrmType_Boundary	then
			_xPosR_pnlB1 = -(frmWdtR + gskWdtR)/2
			_yPosR_pnlB1 = gskThk

			_xPosR_pnlB2 = -(frmWdtR + gskWdtR)/2
			_yPosR_pnlB2 = gskThk - pnlThk

			put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlT,	_yPosR_pnlB1 + _yTransR_pnlT,	_pnlHgt,
				ctwWdt + _xPosR_pnlB2 + _xTransR_pnlT,	_yPosR_pnlB2 + _yTransR_pnlT,	_pnlHgt
		endif

		if	iFrmTypeR = FrmType_Mullion	then
			_xPosR_pnlB1 = (-gskWdtR/2)*cos(aFrmR) - (gskThk/cos(aFrmR))*sin(aFrmR) - _xPosR_refer + pnlLct*tan(aFrmR)
			_yPosR_pnlB1 = (-gskWdtR/2)*sin(aFrmR) + (gskThk/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

			_xPosR_pnlB2 = (-gskWdtR/2)*cos(aFrmR) - ((gskThk - pnlThk)/cos(aFrmR))*sin(aFrmR) - _xPosR_refer + pnlLct*tan(aFrmR)
			_yPosR_pnlB2 = (-gskWdtR/2)*sin(aFrmR) + ((gskThk - pnlThk)/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

			if	_yPosTransR[_idxPnl_4] < _yPosR_pnlB1	then
				if	_yPosTransR[_idxPnl_4] > _yPosR_pnlB2	then
					_xPosR_pnlB1 = _xPosTransR[_idxPnl_3]
					_yPosR_pnlB1 = _yPosTransR[_idxPnl_3]

					_xPosR_pnlB2 = _xPosTransR[_idxPnl_4]
					_yPosR_pnlB2 = _yPosTransR[_idxPnl_4]

					_xPosR_pnlB3 = (-gskWdtR/2)*cos(aFrmR) - ((gskThk - pnlThk)/cos(aFrmR))*sin(aFrmR) - _xPosR_refer
					_yPosR_pnlB3 = (-gskWdtR/2)*sin(aFrmR) + ((gskThk - pnlThk)/cos(aFrmR))*cos(aFrmR) + _yPosR_refer

					put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlT,	_yPosR_pnlB1 + _yTransR_pnlT,	_pnlHgt,
						ctwWdt + _xPosR_pnlB2 + _xTransR_pnlT,	_yPosR_pnlB2 + _yTransR_pnlT,	_pnlHgt,
						ctwWdt + _xPosR_pnlB3 + _xTransR_pnlT,	_yPosR_pnlB3 + _yTransR_pnlT,	_pnlHgt
				else
					_xPosR_pnlB1 = _xPosTransR[_idxPnl_3]
					_yPosR_pnlB1 = _yPosTransR[_idxPnl_3]

					_xPosR_pnlB2 = _xPosTransR[_idxPnl_3] - pnlThk/tan(aFrmR)
					_yPosR_pnlB2 = _yPosTransR[_idxPnl_3] - pnlThk

					put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlT,	_yPosR_pnlB1 + _yTransR_pnlT,	_pnlHgt,
						ctwWdt + _xPosR_pnlB2 + _xTransR_pnlT,	_yPosR_pnlB2 + _yTransR_pnlT,	_pnlHgt
				endif
			else
				put	ctwWdt + _xPosR_pnlB1 + _xTransR_pnlT,	_yPosR_pnlB1 + _yTransR_pnlT,	_pnlHgt,
					ctwWdt + _xPosR_pnlB2 + _xTransR_pnlT,	_yPosR_pnlB2 + _yTransR_pnlT,	_pnlHgt
			endif
		endif

		addy	-pnlLct
			addz	_zPosPnl
				ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
			del 1
		del 1
next	i


!===============================================================================================
!	단열재
!===============================================================================================
!	멀리언 타입에 따른 index
if	_bMlnTypeL1	then
	_idxIns_1 = 4
endif
if	_bMlnTypeL2	then
	_idxIns_1 = 7
endif

if	_bMlnTypeR1	then
	_idxIns_2 = 4
endif
if	_bMlnTypeR2	then
	_idxIns_2 = 7
endif

group	"gIns"
	pen			insPen_Elev
	sect_fill	insFill,	insBackPen,	insFillPen,	insPen_Sect

	for	i = 1	to	nTrs + 1
		if	not(iInsType[i] = INS_TYPE_NONE)	then
			if	iInsType[i] = INS_TYPE_1	then
				material	insMat_1
				_insThk = insThk_1
			endif
			if	iInsType[i] = INS_TYPE_2	then
				material	insMat_2
				_insThk = insThk_2
			endif
			if	iInsType[i] = INS_TYPE_3	then
				material	insMat_3
				_insThk = insThk_3
			endif
			if	iInsType[i] = INS_TYPE_4	then
				material	insMat_4
				_insThk = insThk_4
			endif

			if	_insThk > eps	then
				!	단열 철판 두께 변수 정의
				!-----------------------------------------------------------------------------------------------
				_offsetIns = 0
				_spdFrmThk = 0
				if	bSpdFrm	then
					_offsetIns = 0.006
					_spdFrmThk = spdFrmThk
				endif

				!	Height of Insulation / zPosIns
				!-----------------------------------------------------------------------------------------------
				if	nTrs < eps	then
					_insHgt = ctwHgt - (frmWdtB + frmWdtT) - (_offsetIns + _spdFrmThk)*2
					_zPosIns = frmWdtB + (_offsetIns + _spdFrmThk)
				else
					if	i = 1	then
						_insHgt = trsGap[i] - (frmWdtB + trsWdt/2) - (_offsetIns + _spdFrmThk)*2
						_zPosIns = frmWdtB + (_offsetIns + _spdFrmThk)
					endif

					if	i # 1 & i # (nTrs + 1)	then
						_insHgt = (trsGap[i] - trsGap[i - 1]) - trsWdt - (_offsetIns + _spdFrmThk)*2
						_zPosIns = trsGap[i - 1] + trsWdt/2 + (_offsetIns + _spdFrmThk)
					endif

					if	i = (nTrs + 1)	then
						_insHgt = (ctwHgt - trsGap[i - 1]) - (frmWdtT + trsWdt/2) - (_offsetIns + _spdFrmThk)*2
						_zPosIns = trsGap[i - 1] + trsWdt/2 + (_offsetIns + _spdFrmThk)
					endif
				endif

				!	비율
				!-----------------------------------------------------------------------------------------------
				if	nTrs < eps	then
					_ratio_insB = (frmWdtB + (_offsetIns + _spdFrmThk))/ctwHgt
					_ratio_insT = (ctwHgt - frmWdtT - (_offsetIns + _spdFrmThk))/ctwHgt
				else
					if	i = 1	then
						_ratio_insB = (frmWdtB + (_offsetIns + _spdFrmThk))/ctwHgt
						_ratio_insT = (trsGap[i] - trsWdt/2 - (_offsetIns + _spdFrmThk))/ctwHgt
					endif

					if	i # 1 & i # (nTrs + 1)	then
						_ratio_insB = (trsGap[i - 1] + trsWdt/2 + (_offsetIns + _spdFrmThk))/ctwHgt
						_ratio_insT = (trsGap[i] - trsWdt/2 - (_offsetIns + _spdFrmThk))/ctwHgt
					endif

					if	i = (nTrs + 1)	then
						_ratio_insB = (trsGap[i - 1] + trsWdt/2 + (_offsetIns + _spdFrmThk))/ctwHgt
						_ratio_insT = (ctwHgt - frmWdtT - (_offsetIns + _spdFrmThk))/ctwHgt
					endif
				endif

				!	하부 좌표
				!-----------------------------------------------------------------------------------------------
					!	좌측 좌표
					_xTransL_insB = _dxL*_ratio_insB
					_yTransL_insB = _dyL*_ratio_insB

					if	iFrmTypeL = FrmType_Boundary	then
						_xPosL_insB1 = frmWdtL
						_yPosL_insB1 = frmThkL + gskThk - _insThk + _spdFrmThk

						_xPosL_insB2 = frmWdtL
						_yPosL_insB2 = frmThkL + gskThk - _spdFrmThk
					endif

					if	iFrmTypeL = FrmType_Mullion	then
						_xPosL_insB1 = _xPosTransL[_idxIns_1] + _insThk*tan(aFrmL)
						_yPosL_insB1 = _yPosTransL[_idxIns_1] - _insThk + _spdFrmThk

						_xPosL_insB2 = _xPosTransL[_idxIns_1]
						_yPosL_insB2 = _yPosTransL[_idxIns_1] - _spdFrmThk
					endif

					put	_xPosL_insB1 + _xTransL_insB + (_offsetIns + _spdFrmThk),	_yPosL_insB1 + _yTransL_insB,	0,
						_xPosL_insB2 + _xTransL_insB + (_offsetIns + _spdFrmThk),	_yPosL_insB2 + _yTransL_insB,	0

					!	우측 좌표
					_xTransR_insB = _dxR*_ratio_insB
					_yTransR_insB = _dyR*_ratio_insB

					if	iFrmTypeR = FrmType_Boundary	then
						_xPosR_insB1 = -frmWdtR
						_yPosR_insB1 = frmThkR + gskThk - _spdFrmThk

						_xPosR_insB2 = -frmWdtR
						_yPosR_insB2 = frmThkR + gskThk - _insThk + _spdFrmThk
					endif

					if	iFrmTypeR = FrmType_Mullion	then
						_xPosR_insB1 = _xPosTransR[_idxIns_2]
						_yPosR_insB1 = _yPosTransR[_idxIns_2] - _spdFrmThk

						_xPosR_insB2 = _xPosTransR[_idxIns_2] + _insThk*tan(aFrmR)
						_yPosR_insB2 = _yPosTransR[_idxIns_2] - _insThk + _spdFrmThk
					endif

					put	ctwWdt + _xPosR_insB1 + _xTransR_insB - (_offsetIns + _spdFrmThk),	_yPosR_insB1 + _yTransR_insB,	0,
						ctwWdt + _xPosR_insB2 + _xTransR_insB - (_offsetIns + _spdFrmThk),	_yPosR_insB2 + _yTransR_insB,	0

				!	상부 좌표
				!-----------------------------------------------------------------------------------------------
					!	좌측 좌표
					_xTransL_insT = _dxL*_ratio_insT
					_yTransL_insT = _dyL*_ratio_insT

					if	iFrmTypeL = FrmType_Boundary	then
						_xPosL_insT1 = frmWdtL
						_yPosL_insT1 = frmThkL + gskThk - _insThk + _spdFrmThk

						_xPosL_insT2 = frmWdtL
						_yPosL_insT2 = frmThkL + gskThk - _spdFrmThk
					endif

					if	iFrmTypeL = FrmType_Mullion	then
						_xPosL_insT1 = _xPosTransL[_idxIns_1] + _insThk*tan(aFrmL)
						_yPosL_insT1 = _yPosTransL[_idxIns_1] - _insThk + _spdFrmThk

						_xPosL_insT2 = _xPosTransL[_idxIns_1]
						_yPosL_insT2 = _yPosTransL[_idxIns_1] - _spdFrmThk
					endif

					put	_xPosL_insT1 + _xTransL_insT + (_offsetIns + _spdFrmThk),	_yPosL_insT1 + _yTransL_insT,	_insHgt,
						_xPosL_insT2 + _xTransL_insT + (_offsetIns + _spdFrmThk),	_yPosL_insT2 + _yTransL_insT,	_insHgt

					!	우측 좌표
					_xTransR_insT = _dxR*_ratio_insT
					_yTransR_insT = _dyR*_ratio_insT

					if	iFrmTypeR = FrmType_Boundary	then
						_xPosR_insT1 = -frmWdtR
						_yPosR_insT1 = frmThkR + gskThk - _spdFrmThk

						_xPosR_insT2 = -frmWdtR
						_yPosR_insT2 = frmThkR + gskThk - _insThk + _spdFrmThk
					endif

					if	iFrmTypeR = FrmType_Mullion	then
						_xPosR_insT1 = _xPosTransR[_idxIns_2]
						_yPosR_insT1 = _yPosTransR[_idxIns_2] - _spdFrmThk

						_xPosR_insT2 = _xPosTransR[_idxIns_2] + _insThk*tan(aFrmR)
						_yPosR_insT2 = _yPosTransR[_idxIns_2] - _insThk + _spdFrmThk
					endif

					put	ctwWdt + _xPosR_insT1 + _xTransR_insT - (_offsetIns + _spdFrmThk),	_yPosR_insT1 + _yTransR_insT,	_insHgt,
						ctwWdt + _xPosR_insT2 + _xTransR_insT - (_offsetIns + _spdFrmThk),	_yPosR_insT2 + _yTransR_insT,	_insHgt

				addz	_zPosIns
					ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
				del 1
			endif
		endif
	next	i
endgroup


!===============================================================================================
!	단열 철판
!===============================================================================================
!	멀리언 타입에 따른 index
if	_bMlnTypeL1	then
	_idxIns_1 = 4
endif
if	_bMlnTypeL2	then
	_idxIns_1 = 7
endif

if	_bMlnTypeR1	then
	_idxIns_2 = 4
endif
if	_bMlnTypeR2	then
	_idxIns_2 = 7
endif

group	"gSpdFrm"
	pen			insPen_Elev
	sect_fill	65,	insBackPen,	insFillPen,	insPen_Sect
	material	spdFrmMat

	for	i = 1	to	nTrs + 1
		if	not(iInsType[i] = INS_TYPE_NONE)	then
			if	iInsType[i] = INS_TYPE_1	then
				_insThk = insThk_1
			endif
			if	iInsType[i] = INS_TYPE_2	then
				_insThk = insThk_2
			endif
			if	iInsType[i] = INS_TYPE_3	then
				_insThk = insThk_3
			endif
			if	iInsType[i] = INS_TYPE_4	then
				_insThk = insThk_4
			endif

			if	_insThk > eps	then
				!	단열 철판 두께 변수 정의
				!-----------------------------------------------------------------------------------------------
				_offsetIns = 0
				_spdFrmThk = 0
				if	bSpdFrm	then
					_offsetIns = 0.006
					_spdFrmThk = spdFrmThk
				endif

				!	Height of Insulation / zPosIns
				!-----------------------------------------------------------------------------------------------
				if	nTrs < eps	then
					_spdFrmHgt = ctwHgt - (frmWdtB + frmWdtT) - _offsetIns*2
					_zPosSpdFrm = frmWdtB + _offsetIns
				else
					if	i = 1	then
						_spdFrmHgt = trsGap[i] - (frmWdtB + trsWdt/2) - _offsetIns*2
						_zPosSpdFrm = frmWdtB + _offsetIns
					endif

					if	i # 1 & i # (nTrs + 1)	then
						_spdFrmHgt = (trsGap[i] - trsGap[i - 1]) - trsWdt - _offsetIns*2
						_zPosSpdFrm = trsGap[i - 1] + trsWdt/2 + _offsetIns
					endif

					if	i = (nTrs + 1)	then
						_spdFrmHgt = (ctwHgt - trsGap[i - 1]) - (frmWdtT + trsWdt/2) - _offsetIns*2
						_zPosSpdFrm = trsGap[i - 1] + trsWdt/2 + _offsetIns
					endif
				endif

				!	비율
				!-----------------------------------------------------------------------------------------------
				if	nTrs < eps	then
					_ratio_spdFrmB = (frmWdtB + _offsetIns)/ctwHgt
					_ratio_spdFrmT = (ctwHgt - frmWdtT - _offsetIns)/ctwHgt
				else
					if	i = 1	then
						_ratio_spdFrmB = (frmWdtB + _offsetIns)/ctwHgt
						_ratio_spdFrmT = (trsGap[i] - trsWdt/2 - _offsetIns)/ctwHgt
					endif

					if	i # 1 & i # (nTrs + 1)	then
						_ratio_spdFrmB = (trsGap[i - 1] + trsWdt/2 + _offsetIns)/ctwHgt
						_ratio_spdFrmT = (trsGap[i] - trsWdt/2 - _offsetIns)/ctwHgt
					endif

					if	i = (nTrs + 1)	then
						_ratio_spdFrmB = (trsGap[i - 1] + trsWdt/2 + _offsetIns)/ctwHgt
						_ratio_spdFrmT = (ctwHgt - frmWdtT - _offsetIns)/ctwHgt
					endif
				endif

				!	하부 좌표
				!-----------------------------------------------------------------------------------------------
					!	좌측 좌표
					_xTransL_spdFrmB = _dxL*_ratio_spdFrmB
					_yTransL_spdFrmB = _dyL*_ratio_spdFrmB

					if	iFrmTypeL = FrmType_Boundary	then
						_xPosL_spdFrmB1 = frmWdtL
						_yPosL_spdFrmB1 = frmThkL + gskThk - _insThk

						_xPosL_spdFrmB2 = frmWdtL
						_yPosL_spdFrmB2 = frmThkL + gskThk
					endif

					if	iFrmTypeL = FrmType_Mullion	then
						_xPosL_spdFrmB1 = _xPosTransL[_idxIns_1] + _insThk*tan(aFrmL)
						_yPosL_spdFrmB1 = _yPosTransL[_idxIns_1] - _insThk

						_xPosL_spdFrmB2 = _xPosTransL[_idxIns_1]
						_yPosL_spdFrmB2 = _yPosTransL[_idxIns_1]
					endif

					put	_xPosL_spdFrmB1 + _xTransL_spdFrmB + _offsetIns,	_yPosL_spdFrmB1 + _yTransL_spdFrmB,	0,
						_xPosL_spdFrmB2 + _xTransL_spdFrmB + _offsetIns,	_yPosL_spdFrmB2 + _yTransL_spdFrmB,	0

					!	우측 좌표
					_xTransR_spdFrmB = _dxR*_ratio_spdFrmB
					_yTransR_spdFrmB = _dyR*_ratio_spdFrmB

					if	iFrmTypeR = FrmType_Boundary	then
						_xPosR_spdFrmB1 = -frmWdtR
						_yPosR_spdFrmB1 = frmThkR + gskThk

						_xPosR_spdFrmB2 = -frmWdtR
						_yPosR_spdFrmB2 = frmThkR + gskThk - _insThk
					endif

					if	iFrmTypeR = FrmType_Mullion	then
						_xPosR_spdFrmB1 = _xPosTransR[_idxIns_2]
						_yPosR_spdFrmB1 = _yPosTransR[_idxIns_2]

						_xPosR_spdFrmB2 = _xPosTransR[_idxIns_2] + _insThk*tan(aFrmR)
						_yPosR_spdFrmB2 = _yPosTransR[_idxIns_2] - _insThk
					endif

					put	ctwWdt + _xPosR_spdFrmB1 + _xTransR_spdFrmB - _offsetIns,	_yPosR_spdFrmB1 + _yTransR_spdFrmB,	0,
						ctwWdt + _xPosR_spdFrmB2 + _xTransR_spdFrmB - _offsetIns,	_yPosR_spdFrmB2 + _yTransR_spdFrmB,	0

				!	상부 좌표
				!-----------------------------------------------------------------------------------------------
					!	좌측 좌표
					_xTransL_spdFrmT = _dxL*_ratio_spdFrmT
					_yTransL_spdFrmT = _dyL*_ratio_spdFrmT

					if	iFrmTypeL = FrmType_Boundary	then
						_xPosL_spdFrmT1 = frmWdtL
						_yPosL_spdFrmT1 = frmThkL + gskThk - _insThk

						_xPosL_spdFrmT2 = frmWdtL
						_yPosL_spdFrmT2 = frmThkL + gskThk
					endif

					if	iFrmTypeL = FrmType_Mullion	then
						_xPosL_spdFrmT1 = _xPosTransL[_idxIns_1] + _insThk*tan(aFrmL)
						_yPosL_spdFrmT1 = _yPosTransL[_idxIns_1] - _insThk

						_xPosL_spdFrmT2 = _xPosTransL[_idxIns_1]
						_yPosL_spdFrmT2 = _yPosTransL[_idxIns_1]
					endif

					put	_xPosL_spdFrmT1 + _xTransL_spdFrmT + _offsetIns,	_yPosL_spdFrmT1 + _yTransL_spdFrmT,	_spdFrmHgt,
						_xPosL_spdFrmT2 + _xTransL_spdFrmT + _offsetIns,	_yPosL_spdFrmT2 + _yTransL_spdFrmT,	_spdFrmHgt

					!	우측 좌표
					_xTransR_spdFrmT = _dxR*_ratio_spdFrmT
					_yTransR_spdFrmT = _dyR*_ratio_spdFrmT

					if	iFrmTypeR = FrmType_Boundary	then
						_xPosR_spdFrmT1 = -frmWdtR
						_yPosR_spdFrmT1 = frmThkR + gskThk

						_xPosR_spdFrmT2 = -frmWdtR
						_yPosR_spdFrmT2 = frmThkR + gskThk - _insThk
					endif

					if	iFrmTypeR = FrmType_Mullion	then
						_xPosR_spdFrmT1 = _xPosTransR[_idxIns_2]
						_yPosR_spdFrmT1 = _yPosTransR[_idxIns_2]

						_xPosR_spdFrmT2 = _xPosTransR[_idxIns_2] + _insThk*tan(aFrmR)
						_yPosR_spdFrmT2 = _yPosTransR[_idxIns_2] - _insThk
					endif

					put	ctwWdt + _xPosR_spdFrmT1 + _xTransR_spdFrmT - _offsetIns,	_yPosR_spdFrmT1 + _yTransR_spdFrmT,	_spdFrmHgt,
						ctwWdt + _xPosR_spdFrmT2 + _xTransR_spdFrmT - _offsetIns,	_yPosR_spdFrmT2 + _yTransR_spdFrmT,	_spdFrmHgt

				addz	_zPosSpdFrm
					ruled	(nsp/3)/2,	1+2+4+16+32,	get(nsp)
				del 1
			endif
		endif
	next	i
endgroup


!===============================================================================================
!	단열재 & 단열 철판 배치
!===============================================================================================

!	단열재
placegroup	"gIns"

!	단열 철판
placegroup	subgroup("gSpdFrm",	"gIns")


!===============================================================================================
if	GLOB_VIEW_TYPE = 2	then
	if	gs_2D_projection	then
		if	gs_symb_show_projection_to = stProjectionTypes[1] | (gs_symb_show_projection_to = stProjectionTypes[2] & gs_bottom_range_height < gs_cutplane_height)	then	cutend
		if	gs_2D_projection_type <> 6	then	cutend
		if	gs_symb_show_projection_to <> stProjectionTypes[3]	then	cutend
	endif
endif
!===============================================================================================


!===============================================================================================
!	전개도(Elevation)
!===============================================================================================
! if	(_iWinElev = WinElev_ON)	then
if	(_iWinElev = WinElev_ON) & (GLOB_VIEW_TYPE = 4 | GLOB_VIEW_TYPE = 5)	then
	!	전개도 두께
	!-----------------------------------------------------------------------------------------------
	_elevThk = eps

	!	Hotspot
	!-----------------------------------------------------------------------------------------------
	_transX = 0
	if	abs(xPosGuide) < eps	then	_transX = 0.010

	addx	_transX
		hotspot	0,			-yPosGuide,	zPosGuide,	unID,	xPosGuide,	1+128	:	unID = unID + 1
		hotspot	-1,			-yPosGuide,	zPosGuide,	unID,	xPosGuide,	3		:	unID = unID + 1
		hotspot	xPosGuide,	-yPosGuide,	zPosGuide,	unID,	xPosGuide,	2		:	unID = unID + 1
	del 1

	add	xPosGuide,	-yPosGuide,	0
		rotz	aGuide
			addx	(matrixPoint[1][1] + matrixPoint[4][1])/2
				hotspot	0,	0,	0,			unID,	zPosGuide,	1+128	:	unID = unID + 1
				hotspot	0,	0,	-1,			unID,	zPosGuide,	3		:	unID = unID + 1
				hotspot	0,	0,	zPosGuide,	unID,	zPosGuide,	2		:	unID = unID + 1
			del 1
		del 1
	del 1

	!	Guide Point
	!-----------------------------------------------------------------------------------------------
	dim	_guidePoint[][]

		!	Point1
		_guidePoint[1][1] = matrixPoint[1][1]
		_guidePoint[1][2] = matrixPoint[1][3]/cos(aTiltL)

		!	Point2
		_guidePoint[2][1] = matrixPoint[2][1]
		_guidePoint[2][2] = matrixPoint[2][3]/cos(aTiltL)

		!	Point3
		_guidePoint[3][1] = matrixPoint[3][1]
		_guidePoint[3][2] = matrixPoint[3][3]/cos(aTiltR)

		!	Point4
		_guidePoint[4][1] = matrixPoint[4][1]
		_guidePoint[4][2] = matrixPoint[4][3]/cos(aTiltR)

		if	bGuide	then
			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						lin_	_guidePoint[1][1],	_guidePoint[1][2],	0,	_guidePoint[2][1],	_guidePoint[2][2],	0
						hotline	_guidePoint[1][1],	_guidePoint[1][2],	0,	_guidePoint[2][1],	_guidePoint[2][2],	0,	unID	:	unID = unID + 1

						lin_	_guidePoint[2][1],	_guidePoint[2][2],	0,	_guidePoint[3][1],	_guidePoint[3][2],	0
						hotline	_guidePoint[2][1],	_guidePoint[2][2],	0,	_guidePoint[3][1],	_guidePoint[3][2],	0,	unID	:	unID = unID + 1

						lin_	_guidePoint[3][1],	_guidePoint[3][2],	0,	_guidePoint[4][1],	_guidePoint[4][2],	0
						hotline	_guidePoint[3][1],	_guidePoint[3][2],	0,	_guidePoint[4][1],	_guidePoint[4][2],	0,	unID	:	unID = unID + 1

						lin_	_guidePoint[4][1],	_guidePoint[4][2],	0,	_guidePoint[1][1],	_guidePoint[1][2],	0
						hotline	_guidePoint[4][1],	_guidePoint[4][2],	0,	_guidePoint[1][1],	_guidePoint[1][2],	0,	unID	:	unID = unID + 1

						hotspot	_guidePoint[1][1],	_guidePoint[1][2],	0
						hotspot	_guidePoint[2][1],	_guidePoint[2][2],	0
						hotspot	_guidePoint[3][1],	_guidePoint[3][2],	0
						hotspot	_guidePoint[4][1],	_guidePoint[4][2],	0
					del 1
				del 1
			del 1
		endif

	!	좌/우 프레임
	!-----------------------------------------------------------------------------------------------
	pen			frmPen_Elev
	material	frmMat

		!	Ratio
		_elevRatio_frmB = 0
		_elevRatio_frmT = 1
		if	not(bFrmB)	then
			_elevRatio_frmB = frmWdtB/ctwHgt
		endif
		if	not(bFrmT)	then
			_elevRatio_frmT = (ctwHgt - frmWdtT)/ctwHgt
		endif

		!	index_L
		_iMlnTypeL = iMlnType
		if	not(bFrmCapL)	then	_iMlnTypeL = MLN_TYPE1

		if	iCornerType = CORNER_TYPE1	then
			if	_iMlnTypeL = Mln_Type1	then
				_idxElevFrm = 8
			endif
			if	_iMlnTypeL = Mln_Type2	then
				_idxElevFrm = 13
			endif
		endif

		if	iCornerType = CORNER_TYPE2	then
			if	_iMlnTypeL = Mln_Type1	then
				_idxElevFrm = 9
			endif
			if	_iMlnTypeL = Mln_Type2	then
				_idxElevFrm = 14
			endif
		endif

		!	좌측 프레임
		if	bFrmL	then
			dim	_elevFrmL[][]
			if	iFrmTypeL = FrmType_Boundary	then
				!	Point1
				_elevFrmL[1][1] = _dxL*_elevRatio_frmB + _xPosTransL[1]
				_elevFrmL[1][2] = _guidePoint[2][2]*_elevRatio_frmB

				!	Point2
				_elevFrmL[2][1] = _dxL*_elevRatio_frmB + _xPosTransL[6]
				_elevFrmL[2][2] = _guidePoint[2][2]*_elevRatio_frmB

				!	Point3
				_elevFrmL[3][1] = _dxL*_elevRatio_frmT + _xPosTransL[6]
				_elevFrmL[3][2] = _guidePoint[2][2]*_elevRatio_frmT

				!	Point4
				_elevFrmL[4][1] = _dxL*_elevRatio_frmT + _xPosTransL[1]
				_elevFrmL[4][2] = _guidePoint[2][2]*_elevRatio_frmT
			endif

			if	iFrmTypeL = FrmType_Mullion	then
				if	_iMlnTypeL = Mln_Type1	then
					!	Point1
					_elevFrmL[1][1] = _dxL*_elevRatio_frmB + _xPosTransL[1]
					_elevFrmL[1][2] = _guidePoint[2][2]*_elevRatio_frmB

					!	Point2
					_elevFrmL[2][1] = _dxL*_elevRatio_frmB + _xPosTransL[_idxElevFrm]
					_elevFrmL[2][2] = _guidePoint[2][2]*_elevRatio_frmB

					!	Point3
					_elevFrmL[3][1] = _dxL*_elevRatio_frmT + _xPosTransL[_idxElevFrm]
					_elevFrmL[3][2] = _guidePoint[2][2]*_elevRatio_frmT

					!	Point4
					_elevFrmL[4][1] = _dxL*_elevRatio_frmT + _xPosTransL[1]
					_elevFrmL[4][2] = _guidePoint[2][2]*_elevRatio_frmT
				endif

				if	_iMlnTypeL = Mln_Type2	then
					!	Point1
					_elevFrmL[1][1] = _dxL*_elevRatio_frmB + _xPosTransL[2]
					_elevFrmL[1][2] = _guidePoint[2][2]*_elevRatio_frmB

					!	Point2
					_elevFrmL[2][1] = _dxL*_elevRatio_frmB + _xPosTransL[_idxElevFrm]
					_elevFrmL[2][2] = _guidePoint[2][2]*_elevRatio_frmB

					!	Point3
					_elevFrmL[3][1] = _dxL*_elevRatio_frmT + _xPosTransL[_idxElevFrm]
					_elevFrmL[3][2] = _guidePoint[2][2]*_elevRatio_frmT

					!	Point4
					_elevFrmL[4][1] = _dxL*_elevRatio_frmT + _xPosTransL[2]
					_elevFrmL[4][2] = _guidePoint[2][2]*_elevRatio_frmT
				endif
			endif

			for	i = 1	to	4
				put	_elevFrmL[i][1],	_elevFrmL[i][2],	15
			next	i

			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						prism_	nsp/3,	_elevThk,	get(nsp)
					del 1
				del 1
			del 1
		endif

		!	index_R
		_iMlnTypeR = iMlnType
		if	not(bFrmCapR)	then	_iMlnTypeR = MLN_TYPE1

		if	iCornerType = CORNER_TYPE1	then
			if	_iMlnTypeR = Mln_Type1	then
				_idxElevFrm = 8
			endif
			if	_iMlnTypeR = Mln_Type2	then
				_idxElevFrm = 13
			endif
		endif

		if	iCornerType = CORNER_TYPE2	then
			if	_iMlnTypeR = Mln_Type1	then
				_idxElevFrm = 9
			endif
			if	_iMlnTypeR = Mln_Type2	then
				_idxElevFrm = 14
			endif
		endif


		!	우측 프레임
		if	bFrmR	then
			dim	_elevFrmR[][]
			if	iFrmTypeR = FrmType_Boundary	then
				!	Point1
				_elevFrmR[1][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[1]
				_elevFrmR[1][2] = _guidePoint[3][2]*_elevRatio_frmB

				!	Point2
				_elevFrmR[2][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[6]
				_elevFrmR[2][2] = _guidePoint[3][2]*_elevRatio_frmB

				!	Point3
				_elevFrmR[3][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[6]
				_elevFrmR[3][2] = _guidePoint[3][2]*_elevRatio_frmT

				!	Point4
				_elevFrmR[4][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[1]
				_elevFrmR[4][2] = _guidePoint[3][2]*_elevRatio_frmT
			endif

			if	iFrmTypeR = FrmType_Mullion	then
				if	_iMlnTypeR = Mln_Type1	then
					!	Point1
					_elevFrmR[1][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[1]
					_elevFrmR[1][2] = _guidePoint[3][2]*_elevRatio_frmB

					!	Point2
					_elevFrmR[2][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[_idxElevFrm]
					_elevFrmR[2][2] = _guidePoint[3][2]*_elevRatio_frmB

					!	Point3
					_elevFrmR[3][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[_idxElevFrm]
					_elevFrmR[3][2] = _guidePoint[3][2]*_elevRatio_frmT

					!	Point4
					_elevFrmR[4][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[1]
					_elevFrmR[4][2] = _guidePoint[3][2]*_elevRatio_frmT
				endif

				if	_iMlnTypeR = Mln_Type2	then
					!	Point1
					_elevFrmR[1][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[2]
					_elevFrmR[1][2] = _guidePoint[3][2]*_elevRatio_frmB

					!	Point2
					_elevFrmR[2][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmB + _xPosTransR[_idxElevFrm]
					_elevFrmR[2][2] = _guidePoint[3][2]*_elevRatio_frmB

					!	Point3
					_elevFrmR[3][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[_idxElevFrm]
					_elevFrmR[3][2] = _guidePoint[3][2]*_elevRatio_frmT

					!	Point4
					_elevFrmR[4][1] = _guidePoint[4][1] + _dxR*_elevRatio_frmT + _xPosTransR[2]
					_elevFrmR[4][2] = _guidePoint[3][2]*_elevRatio_frmT
				endif
			endif

			for	i = 1	to	4
				put	_elevFrmR[i][1],	_elevFrmR[i][2],	15
			next	i

			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						prism_	nsp/3,	_elevThk,	get(nsp)
					del 1
				del 1
			del 1
		endif

	!	상/하 프레임
	!-----------------------------------------------------------------------------------------------
	pen			frmPen_Elev
	material	frmMat

		!	하부 프레임
		if	bFrmB	then
			dim	_elevFrmB[][]
			!	index
			if	_bMlnTypeL1	then	_idxElevL = 1
			if	_bMlnTypeL2	then	_idxElevL = 2

			if	_bMlnTypeR1	then	_idxElevR = 1
			if	_bMlnTypeR2	then	_idxElevR = 2

			!	Boundary
			if	iFrmTypeB = FrmType_Boundary	then
				!	Ratio
				_elevRatio_gskB = ((frmWdtB + gskWdtB)/2)/ctwHgt

				!	Point1
				_elevFrmB[1][1] = _xPosTransL[_idxElevL]
				_elevFrmB[1][2] = 0

				!	Point2
				_elevFrmB[2][1] = _dxL*_elevRatio_gskB + _xPosTransL[_idxElevL]
				_elevFrmB[2][2] = _guidePoint[2][2]*_elevRatio_gskB

				!	Point3
				_elevFrmB[3][1] = _dxR*_elevRatio_gskB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[3][2] = _guidePoint[3][2]*_elevRatio_gskB

				!	Point4
				_elevFrmB[4][1] = (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[4][2] = 0
			endif

			!	Transom : Type1
			if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type1)	then
				!	Ratio
				_elevRatio_posB = ((frmWdtB - gskWdtB)/2)/ctwHgt
				_elevRatio_gskB = ((frmWdtB + gskWdtB)/2)/ctwHgt

				!	Point1
				_elevFrmB[1][1] = _dxL*_elevRatio_posB + _xPosTransL[_idxElevL]
				_elevFrmB[1][2] = _guidePoint[2][2]*_elevRatio_posB

				!	Point2
				_elevFrmB[2][1] = _dxL*_elevRatio_gskB + _xPosTransL[_idxElevL]
				_elevFrmB[2][2] = _guidePoint[2][2]*_elevRatio_gskB

				!	Point3
				_elevFrmB[3][1] = _dxR*_elevRatio_gskB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[3][2] = _guidePoint[3][2]*_elevRatio_gskB

				!	Point4
				_elevFrmB[4][1] = _dxR*_elevRatio_posB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[4][2] = _guidePoint[3][2]*_elevRatio_posB
			endif

			!	Transom : Type2
			if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type2)	then
				!	Ratio
				_elevRatio_posB = 0
				_elevRatio_gskB = frmWdtB/ctwHgt

				!	Point1
				_elevFrmB[1][1] = _dxL*_elevRatio_posB + _xPosTransL[_idxElevL]
				_elevFrmB[1][2] = _guidePoint[2][2]*_elevRatio_posB

				!	Point2
				_elevFrmB[2][1] = _dxL*_elevRatio_gskB + _xPosTransL[_idxElevL]
				_elevFrmB[2][2] = _guidePoint[2][2]*_elevRatio_gskB

				!	Point3
				_elevFrmB[3][1] = _dxR*_elevRatio_gskB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[3][2] = _guidePoint[3][2]*_elevRatio_gskB

				!	Point4
				_elevFrmB[4][1] = _dxR*_elevRatio_posB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmB[4][2] = _guidePoint[3][2]*_elevRatio_posB
			endif


			for	i = 1	to	4
				put	_elevFrmB[i][1],	_elevFrmB[i][2],	15
			next	i

			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						prism_	nsp/3,	_elevThk,	get(nsp)
					del 1
				del 1
			del 1
		endif

		!	상부 프레임
		if	bFrmT	then
			dim	_elevFrmT[][]
			!	index
			if	_bMlnTypeL1	then	_idxElevL = 1
			if	_bMlnTypeL2	then	_idxElevL = 2

			if	_bMlnTypeR1	then	_idxElevR = 1
			if	_bMlnTypeR2	then	_idxElevR = 2

			if	iFrmTypeT = FrmType_Boundary	then
				!	Ratio
				_elevRatio_posT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
				_elevRatio_gskT = 1

				!	Point1
				_elevFrmT[1][1] = _dxL*_elevRatio_posT + _xPosTransL[_idxElevL]
				_elevFrmT[1][2] = _guidePoint[2][2]*_elevRatio_posT

				!	Point2
				_elevFrmT[2][1] = _dxL*_elevRatio_gskT + _xPosTransL[_idxElevL]
				_elevFrmT[2][2] = _guidePoint[2][2]*_elevRatio_gskT

				!	Point3
				_elevFrmT[3][1] = _dxR*_elevRatio_gskT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[3][2] = _guidePoint[3][2]*_elevRatio_gskT

				!	Point4
				_elevFrmT[4][1] = _dxR*_elevRatio_posT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[4][2] = _guidePoint[3][2]*_elevRatio_posT
			endif

			if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type1)	then
				!	Ratio
				_elevRatio_posT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
				_elevRatio_gskT = (ctwHgt - (frmWdtT - gskWdtT)/2)/ctwHgt

				!	Point1
				_elevFrmT[1][1] = _dxL*_elevRatio_posT + _xPosTransL[_idxElevL]
				_elevFrmT[1][2] = _guidePoint[2][2]*_elevRatio_posT

				!	Point2
				_elevFrmT[2][1] = _dxL*_elevRatio_gskT + _xPosTransL[_idxElevL]
				_elevFrmT[2][2] = _guidePoint[2][2]*_elevRatio_gskT

				!	Point3
				_elevFrmT[3][1] = _dxR*_elevRatio_gskT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[3][2] = _guidePoint[3][2]*_elevRatio_gskT

				!	Point4
				_elevFrmT[4][1] = _dxR*_elevRatio_posT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[4][2] = _guidePoint[3][2]*_elevRatio_posT
			endif

			if	(iFrmTypeB = FrmType_Transom) & (iTrsType = Trs_Type2)	then
				!	Ratio
				_elevRatio_posT = (ctwHgt - frmWdtT)/ctwHgt
				_elevRatio_gskT = 1

				!	Point1
				_elevFrmT[1][1] = _dxL*_elevRatio_posT + _xPosTransL[_idxElevL]
				_elevFrmT[1][2] = _guidePoint[2][2]*_elevRatio_posT

				!	Point2
				_elevFrmT[2][1] = _dxL*_elevRatio_gskT + _xPosTransL[_idxElevL]
				_elevFrmT[2][2] = _guidePoint[2][2]*_elevRatio_gskT

				!	Point3
				_elevFrmT[3][1] = _dxR*_elevRatio_gskT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[3][2] = _guidePoint[3][2]*_elevRatio_gskT

				!	Point4
				_elevFrmT[4][1] = _dxR*_elevRatio_posT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevFrmT[4][2] = _guidePoint[3][2]*_elevRatio_posT
			endif

			for	i = 1	to	4
				put	_elevFrmT[i][1],	_elevFrmT[i][2],	15
			next	i

			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						prism_	nsp/3,	_elevThk,	get(nsp)
					del 1
				del 1
			del 1
		endif

	!	트랜섬
	!-----------------------------------------------------------------------------------------------
	pen			frmPen_Elev
	material	frmMat

	dim	_elevTrs[][]
	!	index
	if	_bMlnTypeL1	then	_idxElevL = 1
	if	_bMlnTypeL2	then	_idxElevL = 2

	if	_bMlnTypeR1	then	_idxElevR = 1
	if	_bMlnTypeR2	then	_idxElevR = 2

	if	not(nTrs < eps)	then
		for	i = 1	to	nTrs
			if	iTrsType = Trs_Type1	then
				!	Ratio
				_elevRatio_trsB = (trsGap[i] - trsGskWdt/2)/ctwHgt
				_elevRatio_trsT = (trsGap[i] + trsGskWdt/2)/ctwHgt

				!	Point1
				_elevTrs[1][1] = _dxL*_elevRatio_trsB + _xPosTransL[_idxElevL]
				_elevTrs[1][2] = _guidePoint[2][2]*_elevRatio_trsB

				!	Point2
				_elevTrs[2][1] = _dxL*_elevRatio_trsT + _xPosTransL[_idxElevL]
				_elevTrs[2][2] = _guidePoint[2][2]*_elevRatio_trsT

				!	Point3
				_elevTrs[3][1] = _dxR*_elevRatio_trsT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevTrs[3][2] = _guidePoint[3][2]*_elevRatio_trsT

				!	Point4
				_elevTrs[4][1] = _dxR*_elevRatio_trsB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevTrs[4][2] = _guidePoint[3][2]*_elevRatio_trsB
			endif

			if	iTrsType = Trs_Type2	then
				!	Ratio
				_elevRatio_trsB = (trsGap[i] - trsWdt/2)/ctwHgt
				_elevRatio_trsT = (trsGap[i] + trsWdt/2)/ctwHgt

				!	Point1
				_elevTrs[1][1] = _dxL*_elevRatio_trsB + _xPosTransL[_idxElevL]
				_elevTrs[1][2] = _guidePoint[2][2]*_elevRatio_trsB

				!	Point2
				_elevTrs[2][1] = _dxL*_elevRatio_trsT + _xPosTransL[_idxElevL]
				_elevTrs[2][2] = _guidePoint[2][2]*_elevRatio_trsT

				!	Point3
				_elevTrs[3][1] = _dxR*_elevRatio_trsT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevTrs[3][2] = _guidePoint[3][2]*_elevRatio_trsT

				!	Point4
				_elevTrs[4][1] = _dxR*_elevRatio_trsB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
				_elevTrs[4][2] = _guidePoint[3][2]*_elevRatio_trsB
			endif

			for	j = 1	to	4
				put	_elevTrs[j][1],	_elevTrs[j][2],	15
			next	j

			add	xPosGuide,	-yPosGuide,	zPosGuide
				rotz	aGuide
					rotx	90
						prism_	nsp/3,	_elevThk,	get(nsp)
					del 1
				del 1
			del 1
		next	i
	endif

	!	패널
	!-----------------------------------------------------------------------------------------------
	pen			pnlPen_Elev
	material	pnlMat

	dim	_elevPnl[][]
	!	index
	if	_bMlnTypeL1	then	_idxElevL = 1
	if	_bMlnTypeL2	then	_idxElevL = 2

	if	_bMlnTypeR1	then	_idxElevR = 1
	if	_bMlnTypeR2	then	_idxElevR = 2

	for	i = 1	to	nTrs + 1
		!	Ratio
		if	nTrs < eps	then
			_elevRatio_pnlB = ((frmWdtB + gskWdtB)/2)/ctwHgt
			_elevRatio_pnlT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
		else
			if	i = 1	then
				_elevRatio_pnlB = ((frmWdtB + gskWdtB)/2)/ctwHgt
				_elevRatio_pnlT = (trsGap[i] - trsGskWdt/2)/ctwHgt
			endif

			if	i # 1 & i # (nTrs + 1)	then
				_elevRatio_pnlB = (trsGap[i - 1] + trsGskWdt/2)/ctwHgt
				_elevRatio_pnlT = (trsGap[i] - trsGskWdt/2)/ctwHgt
			endif

			if	i = (nTrs + 1)	then
				_elevRatio_pnlB = (trsGap[i - 1] + trsGskWdt/2)/ctwHgt
				_elevRatio_pnlT = (ctwHgt - (frmWdtT + gskWdtT)/2)/ctwHgt
			endif
		endif

		!	Point1
		_elevPnl[1][1] = _dxL*_elevRatio_pnlB + _xPosTransL[_idxElevL]
		_elevPnl[1][2] = _guidePoint[2][2]*_elevRatio_pnlB

		!	Point2
		_elevPnl[2][1] = _dxL*_elevRatio_pnlT + _xPosTransL[_idxElevL]
		_elevPnl[2][2] = _guidePoint[2][2]*_elevRatio_pnlT

		!	Point3
		_elevPnl[3][1] = _dxR*_elevRatio_pnlT + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
		_elevPnl[3][2] = _guidePoint[3][2]*_elevRatio_pnlT

		!	Point4
		_elevPnl[4][1] = _dxR*_elevRatio_pnlB + (_guidePoint[4][1] + _xPosTransR[_idxElevR])
		_elevPnl[4][2] = _guidePoint[3][2]*_elevRatio_pnlB

		for	j = 1	to	4
			put	_elevPnl[j][1],	_elevPnl[j][2],	8
		next	j

		add	xPosGuide,	-yPosGuide,	zPosGuide
			rotz	aGuide
				rotx	90
					prism_	nsp/3,	_elevThk,	get(nsp)
				del 1
			del 1
		del 1
	next	i
endif

end